<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Research Tool</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Rubik:wght@400;700&display=swap');
    
    :root {
      --text-black: #020202;
      --bg-white: #d3d3d3;
      --panel-grey: #C2C2C2;
      --main-yellow: #FFD241;
      --shadow-grey: #9E9E9E;
      --light-yellow: #FFEDB4;
      --shadow-yellow: #DEB555;
      --light-grey:  #d8d8d8;
      --highlight-white: #FFFFFF;
      --font-family: 'Rubik', Arial, Helvetica, sans-serif;
    }
    html,body { 
      height:100%; 
      margin:0; 
      font-family: var(--font-family); 
      background:var(--bg-white); 
    }
    #wrap { display:flex; height:100vh; overflow:hidden; }

    /* ENTITY MANAGER PANEL (LEFT) */
    #entity-manager {
      width: 290px;
      min-width: 290px;
      background: var(--panel-grey);
      color: var(--text-black);
      padding: 16px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      border-right: 1px solid var(--shadow-grey);
      font-size: 13px;
      overflow: hidden;
    }

    .manager-section {
      margin-bottom: 16px;
    }
    
    .manager-section h3 {
      margin: 0 0 8px 0;
      font-size: 14px;
      font-weight: 700;
      opacity: 0.7;
    }
    
    .upload-area {
      border: 2px dashed var(--shadow-grey);
      border-radius: 8px;
      padding-top: 8px;
      padding-left: 8px;
      padding-right: 8px;
      padding-bottom: 4px;
      text-align: center;
      background: var(--light-grey);
    }
    
    .button-row {
      display: flex;
      gap: 1px;
      margin-bottom: 4px;
      margin-top: 4px;
    }
    
    .icon-btn {
      flex: 1;
      padding: 0px;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      font-family: var(--font-family);
      font-size: 12px;
      transition: all 0.2s;
    }
    
    .add-btn {
      background: var(--light-grey);
      color: var(--text-black);
    }
    
    .add-btn:hover {
      background: var(--light-yellow);
    }

    .upload-btn {
      background: var(--light-grey);
      color: var(--text-black);
    }
    
    .upload-btn:hover {
      background: var(--light-yellow);
    }
    
    .download-btn {
      background: var(--light-grey);
      color: var(--highlight-white);
    }
    
    .download-btn:hover {
      background: var(--light-yellow);
    }
    
    /* .download-btn.unsaved {
      background: rgba(70,248,128,0.2);
      animation: pulse 2s infinite;
    } */
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    #file-input, #file-input-add {
      display: none;
    }
    
    .status-msg {
      margin-top: 8px;
      font-size: 11px;
      color: var(--text-black);
      min-height: 16px;
      font-weight: 600;
    }
    
    .status-msg.error {
      color: #dc2626;
    }

    /* TAB BUTTONS */
    .tab-buttons {
      display: flex;
      gap: 2px;
      margin-bottom: 0px;
    }
    
    .tab-btn {
      flex: 1;
      font-family: var(--font-family);
      color: #383838;
      background: var(--light-grey);
      border: 1px solid var(--shadow-grey);
      border-bottom: none;
      border-radius: 8px 8px 0 0;
      padding-top: 4px;
      padding-bottom: 4px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    
    .tab-btn img {
      width: 24px;
      height: 24px;
      display: block;
    }
    
    .tab-btn:hover {
      background: var(--light-grey);
    }
    
    .tab-btn.active {
      font-weight: bold;
      color: var(--text-black);
      background: var(--shadow-grey);
      border-color: var(--shadow-grey);
      border-bottom: 1px solid var(--shadow-grey);
      z-index: 1;
    }
    
    /* FORMATTING MENU */
    #formatting-menu {
      flex: 1;
      overflow-y: auto;
      display: none;
      flex-direction: column;
      background: var(--light-grey);
      border-radius: 0 0 10px 10px;  /* No top-left radius */
      border: 1px solid var(--shadow-grey);
      padding: 0px;
    }

      .format-header {
      display: grid;
      gap: 0px;
      padding-top: 13px;
      padding-bottom: 12px;
      padding-left: 0px;
      padding-right: 0px;
      width: 256px;
      height: 42px;
      background: var(--shadow-grey);
      border-bottom: 1px solid var(--text-black);
      font-weight: 700;
      font-size: 11px;
      align-items: center;
      justify-content: center;
    }
    
    /* .format-control {
      margin-top: 16px;
      margin-bottom: 0px;
    }
    
    .format-control label {
      display: block;
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      margin-left: 10px;
      margin-right: 10px;
      margin-bottom: 4px;
      opacity: 0.7;
    } */
    
    .format-control input[type="color"] {
      width: 33%;
      height: 36px;
      margin-left: 10px;
      margin-right: 10px;
      border: 1px solid var(--shadow-grey);
      border-radius: 4px;
      cursor: pointer;
    }
    
    .format-control input[type="number"] {
      width: 27%;
      padding: 6px;
      margin-left: 10px;
      margin-right: 10px;
      border: 1px solid var(--shadow-grey);
      border-radius: 4px;
      font-family: var(--font-family);
      font-size: 12px;
    }

    .format-subheader {
      font-size: 14px;
      font-weight: 700;
      text-transform: uppercase;
      color: var(--text-black);
      margin-bottom: 6px;
      border-bottom: 1px solid var(--shadow_grey);
      padding-top: 12px;
      padding-left: 8px;
      padding-bottom: 2px;
    }

    .format-divider {
      border: none;
      border-top: 1px solid var(--shadow-grey);
      margin: 12px 0;
    }

    .format-control {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 6px 0;
    }

    .format-control label {
      font-size: 13px;
      color: var(--text-black);
      padding-left: 16px;
    }

    .format-control input {
      margin-left: 8px;
    }

    /* ENTITY TABLE */
    #entity-table-container {
      flex: 1;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      background: var(--light-grey);
      border-radius: 0 0px 10px 10px;  /* No top-left radius */
      border: 1px solid var(--shadow-grey);
    }
    
    .table-header {
      display: grid;
      grid-template-columns: 1fr 60px 20px;
      gap: 6px;
      padding-top: 4px;
      padding-bottom: 0px;
      padding-left: 8px;
      padding-right: 8px;
      background: var(--shadow-grey);
      border-bottom: 1px solid var(--text-black);
      font-weight: 700;
      font-size: 11px;
      text-transform: uppercase;
      align-items: center;
    }
    
    .show-controls {
      display: flex;
      flex-direction: column; /* Stack vertically */
      gap: 4px;
      /* justify-content: center; */
      align-items: center;
    }
    
    /* new helper for the two buttons to sit horizontally */
    .show-buttons {
      display: flex;
      flex-direction: row;
      gap: 4px;
      align-items: center;
    }

    .show-toggle-btn {
      background: var(--main-yellow);
      color: var(--text-black);
      border: none;
      border-radius: 3px;
      padding: 2px 4px;
      cursor: pointer;
      font-size: 9px;
      font-family: var(--font-family);
      font-weight: 700;
    }
    
    .show-toggle-btn:hover {
      background: var(--light-yellow);
      color: var(--text-black);
    }
    
    #entity-table {
      flex: 1;
      overflow-y: auto;
      padding: 4px;
    }
    
    .entity-row {
      display: grid;
      grid-template-columns: 1fr 64px 20px;
      gap: 4px;
      padding: 6px 4px;
      border-bottom: 1px solid rgba(0,0,0,0.1);
      align-items: center;
    }
    
    .entity-row:hover {
      background: rgba(255,255,255,0.5);
    }
    
    .entity-row.selected {
      background: var(--light-yellow);
    }
    
    .entity-name {
      cursor: pointer;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      font-size: 12px;
    }
    
    .entity-name:hover {
      color: var(--shadow-yellow);
    }
    
    .entity-checkbox {
      width: 16px;
      height: 16px;
      cursor: pointer;
      margin: 0 auto;
      display: block;
    }
    
    .empty-state {
      padding: 40px 20px;
      text-align: center;
      color: var(--shadow-grey);
    }

    /* GRAPH AREA */
    #graph-area { position:relative; flex:1; background:var(--bg-white); }
    canvas { width:100%; height:100%; display:block; background:var(--bg-white); }

    /* LOGO */
    #logo {
      position: absolute;
      bottom: 6px;
      right: 20px;
      z-index: 10;
      opacity: 1;
      pointer-events: none;
    }
    
    #logo img {
      height: 50px;
      width: auto;
    }

    /* TOP CONTROLS - ZOOM */
    #top-controls {
      position: absolute;
      top: 12px;
      right: 12px;
      display: flex;
      gap: 12px;
      z-index: 10;
    }

    #zoom-controls {
      display: flex;
      gap: 8px;
    }
    
    .zoom-btn {
      padding: 6px 8px;
      border-radius: 20px;
      border: none;
      cursor: pointer;
      background: var(--panel-grey);
      color: var(--text-black);
      font-size: 18px;
      font-weight: bold;
      min-width: 35px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: var(--font-family);
    }
    
    .zoom-btn:hover {
      background: var(--light-yellow);
    }

    /* INFO PANEL (RIGHT) */
    #info-panel {
      width: 290px;
      min-width: 290px;
      max-width: 290px;
      background: var(--panel-grey);
      color: var(--text-black);
      padding: 12px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      border-left: 1px solid var(--shadow-grey);
      font-size: 13px;
      height: 100vh;
      overflow: hidden;
    }
    
    #controls { 
      display: flex; 
      gap: 8px; 
      align-items: center; 
      flex-shrink: 0; 
      margin-bottom: 8px;
    }
    #search-box { display: flex; width: 100%; gap: 6px; flex-wrap: wrap; }
    #search-input { 
      flex: 1; 
      min-width: 0;
      padding: 6px 8px; 
      border-radius: 4px; 
      border: 1px solid var(--shadow-grey); 
      background: rgba(255,255,255,0.5); 
      color: var(--text-black);
      font-family: var(--font-family); 
    }
    #search-btn, #clear-btn { 
      padding: 8px 8px; 
      border-radius: 4px; 
      border: none; 
      cursor: pointer; 
      background: var(--main-yellow); 
      color: var(--text-black);
      font-family: var(--font-family);
      font-weight: bold;
      flex-shrink: 0;
      white-space: nowrap;
    }
    
    #search-btn:hover, #clear-btn:hover {
      background: var(--light-yellow);
    }

    #suggestions { 
      background: rgba(255,255,255,0.5); 
      border: 1px solid var(--shadow-grey); 
      max-height: 160px; 
      overflow: auto; 
      display: none; 
      padding: 6px; 
      border-radius: 4px; 
    }
    .suggestion { 
      padding: 6px; 
      cursor: pointer; 
      border-bottom: 1px dashed var(--shadow-grey); 
    }
    .suggestion:hover { 
      background: var(--light-yellow); 
    }

    #node-info { 
      margin-top: 8px; 
      padding: 8px; 
      background: var(--panel-grey); 
      border-radius: 6px; 
      flex-shrink: 0;
    }
    #node-title { font-weight: 700; }
    .muted { color: var(--shadow-grey); font-weight: 700; }

    #node-links {
      margin-top: 8px;
      flex-shrink: 0;
    }

    #connections-box {
      margin-top: -6px;
      background: var(--light-grey);
      border-radius: 6px;
      padding: 6px;
      overflow: auto;
      border: 1px solid var(--shadow-grey);
      flex: 1;
      min-height: 0;
    }
    .conn-item {
      padding: 6px;
      cursor: pointer;
      font-size: 13px;
      color: var(--text-black);
      border-bottom: 1px dashed var(--shadow-grey);
    }
    .conn-item:hover { 
      background: var(--light-yellow); 
    }

    #msg { margin-top: 6px; color: #dc2626; font-size: 13px; min-height: 18px; }

    /* LOADING OVERLAY */
    #loading-overlay {
      position: fixed;
      left: 0;
      top: 0;
      right: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 10px;
      background: rgba(250,250,250,0.9);
      z-index: 99999;
      font-size: 16px;
      color: var(--text-black);
    }
    .spinner {
      width: 64px;
      height: 64px;
      border-radius: 50%;
      border: 8px solid var(--shadow-grey);
      border-left-color: var(--main-yellow);
      animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* CONFIRM DIALOG */
    #confirm-dialog {
      position: fixed;
      left: 0;
      top: 0;
      right: 0;
      bottom: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.5);
      z-index: 100000;
    }
    
    .confirm-box {
      background: var(--highlight-white);
      border: 2px solid var(--text-black);
      border-radius: 8px;
      padding: 24px;
      max-width: 400px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    
    .confirm-message {
      font-size: 16px;
      margin-bottom: 20px;
      color: var(--text-black);
      font-weight: 600;
    }
    
    .confirm-buttons {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
    }
    
    .confirm-btn {
      padding: 8px 20px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-family: var(--font-family);
      font-weight: 600;
      font-size: 14px;
    }
    
    .confirm-yes {
      background: #dc2626;
      color: white;
    }
    
    .confirm-yes:hover {
      background: #b91c1c;
    }
    
    .confirm-no {
      background: var(--shadow-grey);
      color: white;
    }
    
    .confirm-no:hover {
      background: var(--text-black);
    }

    /* responsive */
    @media (max-width: 1200px) { 
      #entity-manager { width: 280px; min-width: 280px; }
      #entity-toggle.panel-open { left: 280px; }
      #info-panel { width: 280px; min-width: 280px; max-width: 280px; } 
    }
  </style>
</head>
<body>
  <div id="wrap">
    
    <aside id="entity-manager">
      <div class="manager-section">
        <div class="upload-area">
          <br>
          <p style="margin: 0 0 8px 0; opacity: 0.7; font-size: 13px;">
            <a href="https://docs.google.com/presentation/d/e/2PACX-1vRNfGtXRnwofGlAjKaeIbvKVWtlvpLfEK72sobg8WMamiZ9akXBC97C6PWJQstHp7iCLk-WPgSvlS9k/pub?start=false&loop=false&delayms=30000" target="_blank" style="color: inherit; text-decoration: underline;">
              Learn how to start using this tool
            </a>
          </p>

          <input type="file" id="file-input" accept=".csv" multiple />
          <input type="file" id="file-input-add" accept=".csv" multiple />

          <div class="button-row">
            <button class="icon-btn upload-btn" onclick="document.getElementById('file-input').click()" title="Upload/Replace Data">
              <img src="https://i.ibb.co/Y4QvYnZ1/UPicon.png" alt="Upload/Replace Data" style="width:70px; height:70px;">
            </button>
            <button class="icon-btn add-btn" onclick="document.getElementById('file-input-add').click()" title="Add to Current Data">
              <img src="https://i.ibb.co/b5mC25yP/ADDicon.png" alt="Add to Current Data" style="width:70px; height:70px;">
            </button>
            <button class="icon-btn download-btn" id="download-btn" onclick="handleDownload()" title="Download CSVs">
              <img src="https://i.ibb.co/99NngYsW/DOWNicon.png" alt="Download CSVs" style="width:70px; height:70px;">
            </button>
          </div>

          <div class="status-msg" id="status-msg"></div>
        </div>
      </div>
      
      <div class="manager-section" style="flex: 1; display: flex; flex-direction: column; min-height: 0;">
        <div class="tab-buttons">
          <button class="tab-btn active" id="entities-tab" title="Entities List">
            Entities List
            <!-- <img src="https://i.ibb.co/ZpGssqP2/Entities.png" alt="Entities"> -->
          </button>
          <button class="tab-btn" id="formatting-tab" title="Formatting Menu">
            Formatting
            <!-- <img src="https://i.ibb.co/8LvBWyHR/Formatting2.png" alt="Formatting"> -->
          </button>
        </div>
        
        <div id="entity-table-container">
          <div class="table-header">
            <div>Name</div>
              <div class="show-controls">
                <span style="font-size: 10px;">Show</span>
                <div class="show-buttons">
                  <button class="show-toggle-btn" onclick="toggleAllShow(true)" title="Show All">All</button>
                  <button class="show-toggle-btn" onclick="toggleAllShow(false)" title="Hide All">None</button>
                </div>
              </div>
            <div style="text-align: center;">Fix</div>
            <div></div>
          </div>
          <div id="entity-table">
            <div class="empty-state">
              Upload CSVs to get started
            </div>
          </div>
        </div>
        
        <div id="formatting-menu">
          <div class="format-header" style="display: flex; justify-content: center; align-items: center; font-size: 14px;">
            <div style="text-align: center; font-weight: bold;">DESIGN OPTIONS</div>
          </div>
          <div class="format-section">
          <h3 class="format-subheader">Node</h3>
          <div class="format-control">
            <label>Node Color</label>
            <input type="color" id="fmt-node-color" value="#000000">
          </div>
          <h3 class="format-subheader">Node Outline</h3>
          <div class="format-control">
            <label>Color</label>
            <input type="color" id="fmt-outline-color" value="#dadada">
          </div>
          <div class="format-control">
            <label>Thickness</label>
            <input type="number" id="fmt-outline-thickness" value="4" min="0" max="10" step="0.5">
          </div>
          <h3 class="format-subheader">Node Size</h3>
          <div class="format-control">
            <label>Size Mode</label>
            <select id="fmt-size-mode" style="padding: 6px; margin-right: 10px; border: 1px solid var(--shadow-grey); border-radius: 4px; font-family: var(--font-family); font-size: 12px;">
              <option value="connections"># of Connections</option>
              <option value="custom">Custom Size</option>
            </select>
          </div>
          <div class="format-control" id="custom-size-control" style="display: none;">
            <label>Custom Size (px)</label>
            <input type="number" id="fmt-custom-size" min="5" max="100" value="20">
          </div>
          <div class="format-control">
            <label>Min Size (px)</label>
            <input type="number" id="fmt-min-size" min="1" max="50" value="5">
          </div>
          <div class="format-control">
            <label>Max Size (px)</label>
            <input type="number" id="fmt-max-size" min="10" max="200" value="100">
          </div>
          <div class="format-control">
            <label>Size Scale: <span id="scale-value">1.0x</span></label>
            <input type="range" id="fmt-size-scale" min="0" max="100" step="1" value="50" style="width: 120px; margin-right: 10px;">
          </div>
        </div>

        <hr class="format-divider">

        <div class="format-section">
          <h3 class="format-subheader">Connection Line</h3>
          <div class="format-control">
            <label>Color</label>
            <input type="color" id="fmt-line-color" value="#000000">
          </div>
          <div class="format-control">
            <label>Thickness</label>
            <input type="number" id="fmt-line-thickness" value="3" min="0.5" max="10" step="0.5">
          </div>
        </div>

        <hr class="format-divider">

        <div class="format-section">
          <h3 class="format-subheader">Other Options</h3>
          <div class="format-control">
            <label>Background Color</label>
            <input type="color" id="fmt-bg-color" value="#dadada">
          </div>
        </div>
        </div>
      </div>
    </aside>
    
    <div id="graph-area">
      <canvas id="canvas"></canvas>
      
      <div id="logo">
        <img src="https://i.ibb.co/RXfZbS8/De-Smog-Logo-small.png" alt="Logo">
      </div>
      
      <div id="top-controls">
        <div id="zoom-controls">
          <button id="zoom-in" class="zoom-btn" title="Zoom In">+</button>
          <button id="zoom-out" class="zoom-btn" title="Zoom Out">−</button>
          <button id="zoom-reset" class="zoom-btn" title="Reset Zoom">↻</button>
        </div>
      </div>

      <div id="loading-overlay" style="display: none;">
        <div class="spinner"></div>
        <div id="loading-text">Processing...</div>
      </div>
    </div>

    <aside id="info-panel">
      <div id="controls">
        <div id="search-box">
          <input id="search-input" placeholder="Search..." />
          <button id="search-btn">Search</button>
        </div>
      </div>

      <button id="clear-btn" style="margin-bottom: 8px; flex-shrink: 0;">Clear Selection</button>

      <div id="suggestions"></div>

      <div id="node-info">
        <div id="node-title">Select an entity to view details</div>
        <div id="node-meta" class="muted" style="margin-top:6px;"></div>
      </div>

      <div id="node-links"></div>

      <div id="connections-box"></div>

      <div id="msg"></div>
    </aside>
  </div>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
  <script>
  /************************************************************************
   * CONFIG
   ************************************************************************/
  const CONFIG = {
    colorPalette: d3.schemeTableau10,
    pointOpacity: 1.0,
    unconnectedOpacity: 0.15,
    linkOpacityNoSelection: 0.8,
    linkOpacitySelected: 0.8,
    labelFontSize: 17,
    labelBoxPadding: 4,
    labelOffsetY: 4,
    labelBoxOpacity: 0.6,
    // sizeRangeFactor: 2,
    gridSize: 50,
    dragDelayMs: 1000, // 1 second hold before drag
    force: {
      linkDistance: 30,
      linkStrength: 0.8,
      chargeStrength: -300,
      collisionPadding: 10,
      velocityDecay: 0.1
    },
    showImages: true,
    maxSuggestions: 12,
    zoomMin: 0.2,
    zoomMax: 5.0,
    zoomStep: 0.2
  };

  const PADDING = 80;

  // Default Formatting Settings that can be customized by user
  let formattingSettings = {
    nodeColor: '#000000',
    outlineColor: '#dadada',
    outlineThickness: 4,
    lineColor: '#000000',
    lineThickness: 3,
    backgroundColor: '#dadada',
    nodeSizeMode: 'connections', // 'connections' or 'custom'
    customNodeSize: 30,
    minNodeSize: 15,
    maxNodeSize: 80,
    sizeScale: 1.0
  };

  // Global state
  let nodes = [];
  let links = [];
  let nodeById = new Map();
  let adjacency = new Map();
  let connectionSources = new Map();
  let nameIndex = [];
  let simulation = null;
  let selectedNode = null;
  let hoveredNode = null;
  let isDragging = false;
  let isDraggingNode = false;
  let draggedNode = null;
  let dragStartX = 0;
  let dragStartY = 0;
  let dragStartPanX = 0;
  let dragStartPanY = 0;
  let hasUnsavedChanges = false;
  let mouseDownNode = null;
  let mouseDownTime = 0;
  let dragDelayTimer = null;

  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { alpha: false });
  
  let zoomLevel = 1.0;
  let panX = 0;
  let panY = 0;

  const loadingOverlay = document.getElementById('loading-overlay');
  const loadingText = document.getElementById('loading-text');
  const searchInput = document.getElementById('search-input');
  const searchBtn = document.getElementById('search-btn');
  const clearBtn = document.getElementById('clear-btn');
  const suggestionsEl = d3.select('#suggestions');
  const nodeTitleEl = d3.select('#node-title');
  const nodeMetaEl = d3.select('#node-meta');
  const nodeLinkEl = d3.select('#node-links');
  const connectionsBox = document.getElementById('connections-box');
  const msgEl = d3.select('#msg');
  const zoomInBtn = document.getElementById('zoom-in');
  const zoomOutBtn = document.getElementById('zoom-out');
  const zoomResetBtn = document.getElementById('zoom-reset');
  const fileInput = document.getElementById('file-input');
  const fileInputAdd = document.getElementById('file-input-add');
  const statusMsg = document.getElementById('status-msg');
  const downloadBtn = document.getElementById('download-btn');
  const confirmDialog = document.getElementById('confirm-dialog');
  const confirmMessage = document.getElementById('confirm-message');
  
  // Tab and formatting elements
  const entitiesTab = document.getElementById('entities-tab');
  const formattingTab = document.getElementById('formatting-tab');
  const entityTableContainer = document.getElementById('entity-table-container');
  const formattingMenu = document.getElementById('formatting-menu');
  const fmtNodeColor = document.getElementById('fmt-node-color');
  const fmtLineColor = document.getElementById('fmt-line-color');
  const fmtLineThickness = document.getElementById('fmt-line-thickness');
  const fmtOutlineColor = document.getElementById('fmt-outline-color');
  const fmtOutlineThickness = document.getElementById('fmt-outline-thickness');
  const fmtBgColor = document.getElementById('fmt-bg-color');
  const fmtSizeMode = document.getElementById('fmt-size-mode');
  const fmtCustomSize = document.getElementById('fmt-custom-size');
  const fmtMinSize = document.getElementById('fmt-min-size');
  const fmtMaxSize = document.getElementById('fmt-max-size');
  const fmtSizeScale = document.getElementById('fmt-size-scale');
  const scaleValueDisplay = document.getElementById('scale-value');
  const customSizeControl = document.getElementById('custom-size-control');

  /************************************************************************
   * CANVAS SETUP
   ************************************************************************/
  function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    const hiResScale = devicePixelRatio * 1.5;
    canvas.width  = Math.max(600, Math.floor(rect.width  * hiResScale));
    canvas.height = Math.max(400, Math.floor(rect.height * hiResScale));
    canvas.style.width = rect.width + 'px';
    canvas.style.height = rect.height + 'px';
    ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
  }
  
  window.addEventListener('resize', () => { 
    resizeCanvas(); 
    if (simulation && simulation.force) { 
      const c = simulation.force('center'); 
      if (c) {
        c.x((canvas.width/devicePixelRatio)/2);
        c.y((canvas.height/devicePixelRatio)/2);
      }
    } 
    render();
  });
  
  resizeCanvas();

  /************************************************************************
   * INITIALIZE FORMATTING CONTROLS
   ************************************************************************/
  function initializeFormattingControls() {
    // Set all UI controls to match default formattingSettings
    fmtNodeColor.value = formattingSettings.nodeColor;
    fmtLineColor.value = formattingSettings.lineColor;
    fmtLineThickness.value = formattingSettings.lineThickness;
    fmtOutlineColor.value = formattingSettings.outlineColor;
    fmtOutlineThickness.value = formattingSettings.outlineThickness;
    fmtBgColor.value = formattingSettings.backgroundColor;
    fmtSizeMode.value = formattingSettings.nodeSizeMode;
    fmtCustomSize.value = formattingSettings.customNodeSize;
    fmtMinSize.value = formattingSettings.minNodeSize;
    fmtMaxSize.value = formattingSettings.maxNodeSize;
    
    // Set size scale slider to 50 (middle position = 1x)
    fmtSizeScale.value = 50;
    scaleValueDisplay.textContent = '1.0x';
    
    // Hide custom size control if not in custom mode
    if (formattingSettings.nodeSizeMode !== 'custom') {
      customSizeControl.style.display = 'none';
    }
  }
  
  // Initialize controls on page load
  initializeFormattingControls();

  /************************************************************************
   * TAB SWITCHING
   ************************************************************************/
  entitiesTab.addEventListener('click', () => {
    entitiesTab.classList.add('active');
    formattingTab.classList.remove('active');
    entityTableContainer.style.display = 'flex';
    formattingMenu.style.display = 'none';
  });
  
  formattingTab.addEventListener('click', () => {
    formattingTab.classList.add('active');
    entitiesTab.classList.remove('active');
    entityTableContainer.style.display = 'none';
    formattingMenu.style.display = 'flex';
  });

  /************************************************************************
   * FORMATTING CONTROLS
   ************************************************************************/
  fmtNodeColor.addEventListener('input', (e) => {
    formattingSettings.nodeColor = e.target.value;
    render();
  });

  fmtLineColor.addEventListener('input', (e) => {
    formattingSettings.lineColor = e.target.value;
    render();
  });
  
  fmtLineThickness.addEventListener('input', (e) => {
    formattingSettings.lineThickness = parseFloat(e.target.value);
    render();
  });
  
  fmtOutlineColor.addEventListener('input', (e) => {
    formattingSettings.outlineColor = e.target.value;
    render();
  });
  
  fmtOutlineThickness.addEventListener('input', (e) => {
    formattingSettings.outlineThickness = parseFloat(e.target.value);
    render();
  });
  
  fmtBgColor.addEventListener('input', (e) => {
    formattingSettings.backgroundColor = e.target.value;
    document.documentElement.style.setProperty('--bg-white', e.target.value);
    render();
  });

  fmtSizeMode.addEventListener('change', (e) => {
    formattingSettings.nodeSizeMode = e.target.value;
    if (e.target.value === 'custom') {
      customSizeControl.style.display = 'flex';
    } else {
      customSizeControl.style.display = 'none';
    }
    updateNodeSizes();
    schedulePhysicsRestart();
    render();
  });

  fmtCustomSize.addEventListener('input', (e) => {
    formattingSettings.customNodeSize = parseFloat(e.target.value);
    if (formattingSettings.nodeSizeMode === 'custom') {
      updateNodeSizes();
      schedulePhysicsRestart();
      render();
    }
  });

  fmtMinSize.addEventListener('input', (e) => {
    formattingSettings.minNodeSize = parseFloat(e.target.value);
    updateNodeSizes();
    schedulePhysicsRestart();
    render();
  });

  fmtMaxSize.addEventListener('input', (e) => {
    formattingSettings.maxNodeSize = parseFloat(e.target.value);
    updateNodeSizes();
    schedulePhysicsRestart();
    render();
  });

  fmtSizeScale.addEventListener('input', (e) => {
    const sliderValue = parseFloat(e.target.value);
    let scale;
    
    // Map slider value (0-100) to scale (0.1x-10x) with 50=1x
    if (sliderValue <= 50) {
      // 0-50 maps to 0.1x-1x (linear)
      scale = 0.1 + (sliderValue / 50) * 0.9;
    } else {
      // 50-100 maps to 1x-10x (linear)
      scale = 1.0 + ((sliderValue - 50) / 50) * 9.0;
    }
    
    formattingSettings.sizeScale = scale;
    scaleValueDisplay.textContent = scale.toFixed(1) + 'x';
    applyNodeSizeScale();
    schedulePhysicsRestart();
    render();
  });

  /************************************************************************
   * FILE UPLOAD - REPLACE
   ************************************************************************/
  fileInput.addEventListener('change', async (e) => {
    await handleFileUpload(e.target.files, false);
    fileInput.value = '';
  });

  /************************************************************************
   * FILE UPLOAD - ADD
   ************************************************************************/
  fileInputAdd.addEventListener('change', async (e) => {
    await handleFileUpload(e.target.files, true);
    fileInputAdd.value = '';
  });

  async function handleFileUpload(files, isAppend) {
    const filesArray = Array.from(files);
    
    if (filesArray.length === 0) return;
    
    if (filesArray.length < 2 || filesArray.length > 3) {
      showStatus('Please select Entities.csv, Connections.csv, and optionally Formatting.csv', 'error');
      return;
    }
    
    const entitiesFile = filesArray.find(f => f.name.toLowerCase().includes('entities'));
    const connectionsFile = filesArray.find(f => f.name.toLowerCase().includes('connections') || f.name.toLowerCase().includes('links'));
    const formattingFile = filesArray.find(f => f.name.toLowerCase().includes('formatting'));
    
    if (!entitiesFile || !connectionsFile) {
      showStatus('Files must include "Entities" and "Connections" (or "Links") in their names', 'error');
      return;
    }
    
    loadingOverlay.style.display = 'flex';
    loadingText.textContent = isAppend ? 'Adding CSVs...' : 'Loading CSVs...';
    
    try {
      const promises = [
        parseCSVFile(entitiesFile),
        parseCSVFile(connectionsFile)
      ];
      if (formattingFile) {
        promises.push(parseCSVFile(formattingFile));
      }
      
      const results = await Promise.all(promises);
      const entitiesData = results[0];
      const connectionsData = results[1];
      const formattingData = formattingFile ? results[2] : null;
      
      if (formattingData && formattingData.length > 0) {
        loadFormattingSettings(formattingData[0]);
      }
      
      if (isAppend) {
        appendSession(entitiesData, connectionsData);
        showStatus(`Added ${entitiesData.length} entities`, 'success');
      } else {
        loadSession(entitiesData, connectionsData);
        showStatus(`Loaded ${nodes.length} entities, ${links.length} connections`, 'success');
      }
      
      hasUnsavedChanges = false;
      updateDownloadButton();
    } catch (err) {
      console.error('CSV parse error', err);
      showStatus('Failed to parse CSV files', 'error');
      loadingOverlay.style.display = 'none';
    }
  }

  function parseCSVFile(file) {
    return new Promise((resolve, reject) => {
      Papa.parse(file, {
        header: true,
        skipEmptyLines: true,
        complete: (results) => resolve(results.data),
        error: (error) => reject(error)
      });
    });
  }

  function loadFormattingSettings(data) {
    if (data.nodeColor) {
      formattingSettings.nodeColor = data.nodeColor;
      fmtNodeColor.value = data.nodeColor;
    }
    if (data.lineColor) {
      formattingSettings.lineColor = data.lineColor;
      fmtLineColor.value = data.lineColor;
    }
    if (data.lineThickness) {
      formattingSettings.lineThickness = parseFloat(data.lineThickness);
      fmtLineThickness.value = data.lineThickness;
    }
    if (data.outlineColor) {
      formattingSettings.outlineColor = data.outlineColor;
      fmtOutlineColor.value = data.outlineColor;
    }
    if (data.outlineThickness) {
      formattingSettings.outlineThickness = parseFloat(data.outlineThickness);
      fmtOutlineThickness.value = data.outlineThickness;
    }
    if (data.backgroundColor) {
      formattingSettings.backgroundColor = data.backgroundColor;
      fmtBgColor.value = data.backgroundColor;
      document.documentElement.style.setProperty('--bg-white', data.backgroundColor);
    }
  }

  function showStatus(msg, type = 'success') {
    statusMsg.textContent = msg;
    statusMsg.className = 'status-msg' + (type === 'error' ? ' error' : '');
    setTimeout(() => {
      statusMsg.textContent = '';
    }, 5000);
  }

  /************************************************************************
   * LOAD SESSION (REPLACE)
   ************************************************************************/
  function loadSession(entitiesData, connectionsData) {
    // Clean headers
    entitiesData.forEach(r => { 
      Object.keys(r).forEach(k => { 
        if (k !== k.trim()) { 
          r[k.trim()] = r[k]; 
          delete r[k]; 
        } 
      }); 
    });
    
    connectionsData.forEach(r => { 
      Object.keys(r).forEach(k => { 
        if (k !== k.trim()) { 
          r[k.trim()] = r[k]; 
          delete r[k]; 
        } 
      }); 
    });

    // Create nodes
    nodes = entitiesData.map((d, i) => createNodeFromData(d, i));
    nodeById = new Map(nodes.map(n => [n.id, n]));

    // Create links
    processLinksData(connectionsData);

    // Build adjacency
    buildAdjacency();

    nameIndex = nodes.map(n => n.name);

    // Calculate node sizes
    updateNodeSizes();

    // Load images
    loadAllImages();

    // Update entity table
    updateEntityTable();

    // Start physics
    updatePhysics();

    loadingOverlay.style.display = 'none';
  }

  /************************************************************************
   * APPEND SESSION (ADD)
   ************************************************************************/
  function appendSession(entitiesData, connectionsData) {
    // Clean headers
    entitiesData.forEach(r => { 
      Object.keys(r).forEach(k => { 
        if (k !== k.trim()) { 
          r[k.trim()] = r[k]; 
          delete r[k]; 
        } 
      }); 
    });
    
    connectionsData.forEach(r => { 
      Object.keys(r).forEach(k => { 
        if (k !== k.trim()) { 
          r[k.trim()] = r[k]; 
          delete r[k]; 
        } 
      }); 
    });

    // Add or update nodes
    entitiesData.forEach((d, i) => {
      const newNode = createNodeFromData(d, i);
      const existing = nodeById.get(newNode.id);
      
      if (existing) {
        // Replace existing node with new data
        const index = nodes.indexOf(existing);
        nodes[index] = newNode;
        nodeById.set(newNode.id, newNode);
      } else {
        // Add new node
        nodes.push(newNode);
        nodeById.set(newNode.id, newNode);
      }
    });

    // Process links
    processLinksData(connectionsData);

    // Rebuild adjacency
    buildAdjacency();

    nameIndex = nodes.map(n => n.name);

    // Recalculate node sizes
    updateNodeSizes();

    // Load new images
    loadAllImages();

    // Update entity table
    updateEntityTable();

    // Restart physics
    updatePhysics();

    loadingOverlay.style.display = 'none';
  }

  function createNodeFromData(d, i) {
    const id = d['Entity Name'] ? String(d['Entity Name']).trim() : `__P_${i}`;
    
    // Parse Show/Fixed/X/Y from CSV
    const show = d['Show'] === undefined ? true : (d['Show'] === 'true' || d['Show'] === '1' || d['Show'] === true);
    const isFixed = d['Fixed'] === 'true' || d['Fixed'] === '1' || d['Fixed'] === true;
    const savedX = parseFloat(d['X']);
    const savedY = parseFloat(d['Y']);
    
    const x = !isNaN(savedX) && isFixed ? savedX : Math.random() * (canvas.width/devicePixelRatio);
    const y = !isNaN(savedY) && isFixed ? savedY : Math.random() * (canvas.height/devicePixelRatio);
    
    return {
      id, 
      name: id, 
      raw: d, 
      show,
      isFixed,
      image: d['Image'] ? d['Image'].trim() : null, 
      imageBitmap: null,
      x, 
      y,
      fx: isFixed ? x : null,
      fy: isFixed ? y : null,
      unfixedX: null,
      unfixedY: null,
      vx: 0, 
      vy: 0, 
      r: CONFIG.sizeMin
    };
  }

  function processLinksData(connectionsData) {
    const tmpLinks = connectionsData.map(r => ({
      sourceName: (r['A']||'').toString().trim(),
      targetName: (r['B']||'').toString().trim(),
      value: +((r['Link Size']||r['LinkSize']) || 1) || 1,
      source: (r['Source']||'').toString().trim()
    })).filter(l => l.sourceName && l.targetName);

    // Add missing nodes from links
    tmpLinks.forEach(l => {
      if (!nodeById.has(l.sourceName)) {
        const n = { 
          id: l.sourceName, 
          name: l.sourceName, 
          raw: {}, 
          show: true,
          isFixed: false,
          image: null, 
          imageBitmap: null, 
          x: Math.random() * canvas.width, 
          y: Math.random() * canvas.height, 
          fx: null,
          fy: null,
          unfixedX: null,
          unfixedY: null,
          vx: 0, 
          vy: 0, 
          r: CONFIG.sizeMin 
        };
        nodes.push(n); 
        nodeById.set(n.id, n);
      }
      if (!nodeById.has(l.targetName)) {
        const n = { 
          id: l.targetName, 
          name: l.targetName, 
          raw: {}, 
          show: true,
          isFixed: false,
          image: null, 
          imageBitmap: null, 
          x: Math.random() * canvas.width, 
          y: Math.random() * canvas.height,
          fx: null,
          fy: null,
          unfixedX: null,
          unfixedY: null,
          vx: 0, 
          vy: 0, 
          r: CONFIG.sizeMin 
        };
        nodes.push(n); 
        nodeById.set(n.id, n);
      }
    });

    links = tmpLinks.map(l => ({ 
      source: nodeById.get(l.sourceName), 
      target: nodeById.get(l.targetName), 
      value: l.value,
      sourceUrl: l.source
    })).filter(l => l.source && l.target);
  }

  function buildAdjacency() {
    adjacency = new Map(); 
    connectionSources = new Map();
    nodes.forEach(n => {
      adjacency.set(n.id, new Set());
      connectionSources.set(n.id, new Map());
    });
    links.forEach(l => {
      adjacency.get(l.source.id).add(l.target.id);
      adjacency.get(l.target.id).add(l.source.id);
      
      if (l.sourceUrl) {
        connectionSources.get(l.source.id).set(l.target.id, l.sourceUrl);
        connectionSources.get(l.target.id).set(l.source.id, l.sourceUrl);
      }
    });
  }

  function updateNodeSizes() {
    const minSize = formattingSettings.minNodeSize;
    const maxSize = formattingSettings.maxNodeSize;
    
    if (formattingSettings.nodeSizeMode === 'custom') {
      // Use custom size for all nodes
      const customSize = formattingSettings.customNodeSize;
      nodes.forEach(n => {
        n.baseR = customSize;
      });
    } else {
      // Calculate size based on connections: 250 * (N / T)
      // N = Number of connections for entity
      // T = Total number of connections for all entities
      
      // Calculate total connections across all entities
      let totalConnections = 0;
      nodes.forEach(n => {
        const connections = adjacency.get(n.id);
        totalConnections += connections ? connections.size : 0;
      });
      
      // Avoid division by zero
      if (totalConnections === 0) {
        nodes.forEach(n => {
          n.baseR = minSize; // Use minimum size
        });
        applyNodeSizeScale();
        return;
      }
      
      // Calculate size for each node
      nodes.forEach(n => {
        const connections = adjacency.get(n.id);
        const connectionCount = connections ? connections.size : 0;
        const size = 250 * (connectionCount / totalConnections);
        n.baseR = Math.max(minSize, Math.min(size, maxSize)); // Clamp between min and max
      });
    }
    
    applyNodeSizeScale();
  }

  function applyNodeSizeScale() {
    const scale = formattingSettings.sizeScale;
    nodes.forEach(n => {
      n.r = (n.baseR || 15) * scale;
    });
  }

  function loadAllImages() {
    const imgNodes = nodes.filter(n => n.image && CONFIG.showImages);
    Promise.allSettled(imgNodes.map(n => loadImage(n))).then(() => render());
  }

  function loadImage(node) {
    return new Promise(async resolve => {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000);
        const resp = await fetch(node.image, { mode: 'cors', signal: controller.signal }).catch(()=>null);
        clearTimeout(timeoutId);
        if (!resp || !resp.ok) throw new Error('fetch failed');
        const blob = await resp.blob();
        if (typeof createImageBitmap === 'function') {
          const bmp = await createImageBitmap(blob, { resizeQuality: 'high' });
          node.imageBitmap = bmp;
          resolve();
        } else {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => { node.imageBitmap = img; resolve(); };
          img.onerror = () => { node.imageBitmap = null; resolve(); };
          img.src = URL.createObjectURL(blob);
        }
      } catch (err) {
        // Try direct image load as fallback
        try {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => { node.imageBitmap = img; resolve(); };
          img.onerror = () => { node.imageBitmap = null; resolve(); };
          img.src = node.image;
        } catch (e) {
          node.imageBitmap = null;
          resolve();
        }
      }
    });
  }

  /************************************************************************
   * ENTITY TABLE
   ************************************************************************/
  function updateEntityTable() {
    const tableEl = document.getElementById('entity-table');
    
    if (nodes.length === 0) {
      tableEl.innerHTML = '<div class="empty-state">Upload CSVs to get started</div>';
      return;
    }
    
    tableEl.innerHTML = '';
    
    nodes.forEach(node => {
      const row = document.createElement('div');
      row.className = 'entity-row';
      if (selectedNode && selectedNode.id === node.id) {
        row.classList.add('selected');
      }
      
      // Name
      const nameEl = document.createElement('div');
      nameEl.className = 'entity-name';
      nameEl.textContent = node.name;
      nameEl.title = node.name;
      nameEl.addEventListener('click', () => {
        selectedNode = node;
        populateInfoPanel(node);
        updateEntityTable();
        render();
      });
      row.appendChild(nameEl);
      
      // Show checkbox
      const showCell = document.createElement('div');
      showCell.style.textAlign = 'center';
      const showCheck = document.createElement('input');
      showCheck.type = 'checkbox';
      showCheck.className = 'entity-checkbox';
      showCheck.checked = node.show;
      showCheck.addEventListener('change', (e) => {
        node.show = e.target.checked;
        markDirty();
        schedulePhysicsRestart();
      });
      showCell.appendChild(showCheck);
      row.appendChild(showCell);
      
      // Fixed checkbox
      const fixedCell = document.createElement('div');
      fixedCell.style.textAlign = 'center';
      const fixedCheck = document.createElement('input');
      fixedCheck.type = 'checkbox';
      fixedCheck.className = 'entity-checkbox';
      fixedCheck.checked = node.isFixed;
      fixedCheck.addEventListener('change', (e) => {
        toggleFixed(node, e.target.checked);
      });
      fixedCell.appendChild(fixedCheck);
      row.appendChild(fixedCell);
      
      tableEl.appendChild(row);
    });
  }

  function toggleAllShow(show) {
    nodes.forEach(n => n.show = show);
    markDirty();
    updateEntityTable();
    schedulePhysicsRestart();
  }

  function toggleFixed(node, isFixed) {
    if (isFixed) {
      // Fix the node
      node.isFixed = true;
      node.fx = node.x;
      node.fy = node.y;
    } else {
      // Unfix the node
      node.isFixed = false;
      if (node.unfixedX !== null && node.unfixedY !== null) {
        node.x = node.unfixedX;
        node.y = node.unfixedY;
      }
      node.fx = null;
      node.fy = null;
    }
    
    markDirty();
    schedulePhysicsRestart();
  }

  /************************************************************************
   * PHYSICS
   ************************************************************************/
  let physicsTimer = null;

  function schedulePhysicsRestart() {
    clearTimeout(physicsTimer);
    physicsTimer = setTimeout(() => {
      updatePhysics();
    }, 100);
  }

  function updatePhysics() {
    if (simulation) simulation.stop();
    
    const visibleNodes = nodes.filter(n => n.show);
    const visibleLinks = links.filter(l => l.source.show && l.target.show);
    
    if (visibleNodes.length === 0) {
      render();
      return;
    }
    
    simulation = d3.forceSimulation(visibleNodes)
      .force('link', d3.forceLink(visibleLinks)
        .id(d => d.id)
        .distance(d => Math.max(20, CONFIG.force.linkDistance / Math.sqrt(Math.max(0.5, d.value))))
        .strength(CONFIG.force.linkStrength))
      .force('charge', d3.forceManyBody().strength(CONFIG.force.chargeStrength))
      .force('center', d3.forceCenter(
        (canvas.width/devicePixelRatio)/2, 
        (canvas.height/devicePixelRatio)/2
      ))
      .force('collision', d3.forceCollide().radius(d => d.r + CONFIG.force.collisionPadding))
      .velocityDecay(CONFIG.force.velocityDecay)
      .on('tick', () => {
        visibleNodes.forEach(n => {
          n.x = Math.max(n.r + PADDING, Math.min((canvas.width/devicePixelRatio) - n.r - PADDING, n.x));
          n.y = Math.max(n.r + PADDING, Math.min((canvas.height/devicePixelRatio) - n.r - PADDING, n.y));
          
          // Save unfixed positions
          if (!n.isFixed) {
            n.unfixedX = n.x;
            n.unfixedY = n.y;
          }
        });
        render();
      });
    
    simulation.alpha(0.3).restart();
  }

  /************************************************************************
   * DOWNLOAD
   ************************************************************************/
  function handleDownload() {
    if (nodes.length === 0) {
      showStatus('No data to download', 'error');
      return;
    }
    
    const entitiesCSV = generateEntitiesCSV();
    const connectionsCSV = generateConnectionsCSV();
    const formattingCSV = generateFormattingCSV();
    
    downloadCSV(entitiesCSV, 'Entities.csv');
    setTimeout(() => {
      downloadCSV(connectionsCSV, 'Connections.csv');
    }, 100);
    setTimeout(() => {
      downloadCSV(formattingCSV, 'Formatting.csv');
    }, 200);
    
    hasUnsavedChanges = false;
    updateDownloadButton();
    showStatus('CSVs downloaded successfully', 'success');
  }

  function generateEntitiesCSV() {
    const data = nodes.map(n => ({
      'Entity Name': n.name,
      'Description': n.raw['Description'] || '',
      'Category': n.raw['Category'] || '',
      'Area': n.raw['Area'] || '',
      'Sub Area': n.raw['Sub Area'] || '',
      'Image': n.raw['Image'] || '',
      'Link': n.raw['Link'] || '',
      'More Info': n.raw['More Info'] || '',
      'Show': n.show,
      'Fixed': n.isFixed,
      'X': n.isFixed ? n.x.toFixed(2) : '',
      'Y': n.isFixed ? n.y.toFixed(2) : ''
    }));
    
    return Papa.unparse(data);
  }

  function generateConnectionsCSV() {
    const data = links.map(l => ({
      'A': l.source.id || l.source,
      'B': l.target.id || l.target,
      'Link Size': l.value || 1,
      'Source': l.sourceUrl || ''
    }));
    
    return Papa.unparse(data);
  }
  
  function generateFormattingCSV() {
    const data = [{
      'nodeColor': formattingSettings.nodeColor,   
      'outlineColor': formattingSettings.outlineColor,
      'outlineThickness': formattingSettings.outlineThickness,      
      'lineColor': formattingSettings.lineColor,   
      'lineThickness': formattingSettings.lineThickness,
      'backgroundColor': formattingSettings.backgroundColor
    }];
    
    return Papa.unparse(data);
  }

  function downloadCSV(csvContent, filename) {
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    
    link.setAttribute('href', url);
    link.setAttribute('download', filename);
    link.style.visibility = 'hidden';
    
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    URL.revokeObjectURL(url);
  }

  function markDirty() {
    hasUnsavedChanges = true;
    updateDownloadButton();
  }

  function updateDownloadButton() {
    if (hasUnsavedChanges) {
      downloadBtn.classList.add('unsaved');
      downloadBtn.title = 'You have unsaved changes - Download CSVs';
    } else {
      downloadBtn.classList.remove('unsaved');
      downloadBtn.title = 'Download CSVs';
    }
  }

  // Warn before leaving with unsaved changes
  window.addEventListener('beforeunload', (e) => {
    if (hasUnsavedChanges && nodes.length > 0) {
      e.preventDefault();
      e.returnValue = 'You have unsaved changes. Download CSVs before leaving?';
      return e.returnValue;
    }
  });

  /************************************************************************
   * GRID SNAPPING
   ************************************************************************/
  function snapToGrid(x, y) {
    return {
      x: Math.round(x / CONFIG.gridSize) * CONFIG.gridSize,
      y: Math.round(y / CONFIG.gridSize) * CONFIG.gridSize
    };
  }

  function drawGrid() {
    const width = canvas.width / devicePixelRatio;
    const height = canvas.height / devicePixelRatio;
    
    ctx.save();
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.25)';
    ctx.lineWidth = 2 / zoomLevel;
    
    for (let x = 0; x <= width; x += CONFIG.gridSize) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, height);
      ctx.stroke();
    }
    
    for (let y = 0; y <= height; y += CONFIG.gridSize) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(width, y);
      ctx.stroke();
    }
    
    ctx.restore();
  }

  /************************************************************************
   * RENDERING
   ************************************************************************/
  function clearCanvas() {
    ctx.fillStyle = formattingSettings.backgroundColor;
    ctx.fillRect(0, 0, canvas.width/devicePixelRatio, canvas.height/devicePixelRatio);
  }

  function applyTransform() {
    const centerX = (canvas.width/devicePixelRatio) / 2;
    const centerY = (canvas.height/devicePixelRatio) / 2;
    ctx.translate(centerX + panX, centerY + panY);
    ctx.scale(zoomLevel, zoomLevel);
    ctx.translate(-centerX, -centerY);
  }

  function roundRectPath(x, y, w, h, r) {
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
  }

  function drawLink(l, opacity) {
    ctx.save();
    ctx.globalAlpha = opacity;
    ctx.beginPath();
    ctx.moveTo(l.source.x, l.source.y);
    ctx.lineTo(l.target.x, l.target.y);
    ctx.lineWidth = formattingSettings.lineThickness / zoomLevel;
    ctx.strokeStyle = formattingSettings.lineColor;
    ctx.stroke();
    ctx.restore();
  }

  function drawNode(n, opacity, showImage=true) {
    ctx.save();
    const x = n.x, y = n.y, r = n.r;

    if (showImage && n.imageBitmap) {
      ctx.save();
      ctx.globalAlpha = opacity;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI*2);
      ctx.clip();
      const img = n.imageBitmap;
      const iw = img.width || img.naturalWidth || 1;
      const ih = img.height || img.naturalHeight || 1;
      const target = r * 2;
      const scale = Math.max(target / iw, target / ih);
      const dw = iw * scale;
      const dh = ih * scale;
      const dx = x - dw / 2;
      const dy = y - dh / 2;
      try {
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        ctx.drawImage(img, dx, dy, dw, dh);
      } catch (e) {
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI*2);
        ctx.fillStyle = formattingSettings.nodeColor;
        ctx.fill();
      }
      ctx.restore();
    } else {
      ctx.save();
      ctx.globalAlpha = opacity;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI*2);
      ctx.fillStyle = formattingSettings.nodeColor;
      ctx.fill();
      ctx.restore();
    }

    ctx.save();
    ctx.globalAlpha = opacity;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI*2);
    ctx.lineWidth = formattingSettings.outlineThickness / zoomLevel;
    ctx.strokeStyle = formattingSettings.outlineColor;
    ctx.stroke();
    ctx.restore();

    ctx.restore();
  }

  function drawLabel(n) {
    const text = n.name || '';
    if (!text) return;
    ctx.save();
    ctx.font = `${CONFIG.labelFontSize / zoomLevel}px Rubik, Arial, sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    const metrics = ctx.measureText(text);
    const textW = metrics.width;
    const pad = CONFIG.labelBoxPadding / zoomLevel;
    const boxW = textW + pad * 2;
    const boxH = (CONFIG.labelFontSize + 6) / zoomLevel;
    const x = n.x - boxW / 2;
    const y = n.y + n.r + CONFIG.labelOffsetY / zoomLevel;

    ctx.save();
    ctx.globalAlpha = CONFIG.labelBoxOpacity;
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    roundRectPath(x, y, boxW, boxH, 6 / zoomLevel);
    ctx.fill();
    ctx.restore();

    ctx.fillStyle = '#111827';
    ctx.fillText(text, n.x, y + boxH / 2);
    ctx.restore();
  }

  function shouldHighlightNode(node) {
    if (!selectedNode) return true;
    const activeSet = new Set([selectedNode.id, ...(adjacency.get(selectedNode.id) || [])]);
    return activeSet.has(node.id);
  }

  function render() {
    clearCanvas();
    if (!nodes || nodes.length === 0) return;

    ctx.save();
    applyTransform();

    const visibleNodes = nodes.filter(n => n.show);
    const highlightedNodes = [];
    const unhighlightedNodes = [];
    
    visibleNodes.forEach(node => {
      if (shouldHighlightNode(node)) {
        highlightedNodes.push(node);
      } else {
        unhighlightedNodes.push(node);
      }
    });

    unhighlightedNodes.forEach(n => drawNode(n, CONFIG.unconnectedOpacity, CONFIG.showImages));

    const highlightedSet = new Set(highlightedNodes.map(n => n.id));
    const visibleLinks = links.filter(l => l.source.show && l.target.show);
    
    if (selectedNode) {
      visibleLinks.forEach(l => {
        if (highlightedSet.has(l.source.id) && highlightedSet.has(l.target.id)) {
          drawLink(l, CONFIG.linkOpacitySelected);
        }
      });
    } else {
      visibleLinks.forEach(l => {
        drawLink(l, CONFIG.linkOpacityNoSelection);
      });
    }

    highlightedNodes.forEach(n => drawNode(n, CONFIG.pointOpacity, CONFIG.showImages));

    // Draw grid OVER nodes when dragging
    if (isDraggingNode) {
      ctx.restore();
      ctx.save();
      applyTransform();
      drawGrid();
    }

    if (selectedNode) {
      highlightedNodes.forEach(n => {
        if (adjacency.get(selectedNode.id).has(n.id) || n === selectedNode) {
          drawLabel(n);
        }
      });
    }

    if (hoveredNode && hoveredNode !== selectedNode && hoveredNode.show) {
      drawLabel(hoveredNode);
    }

    ctx.restore();
  }

  /************************************************************************
   * CANVAS INTERACTION
   ************************************************************************/
  function getCanvasPos(evt) {
    const rect = canvas.getBoundingClientRect();
    const x = (evt.clientX - rect.left) * (canvas.width / devicePixelRatio) / rect.width;
    const y = (evt.clientY - rect.top) * (canvas.height / devicePixelRatio) / rect.height;
    
    const centerX = (canvas.width/devicePixelRatio) / 2;
    const centerY = (canvas.height/devicePixelRatio) / 2;
    
    const transformedX = (x - centerX - panX) / zoomLevel + centerX;
    const transformedY = (y - centerY - panY) / zoomLevel + centerY;
    
    return { x: transformedX, y: transformedY };
  }

  function findNodeAtPos(x, y) {
    if (!nodes || nodes.length === 0) return null;
    const visibleNodes = nodes.filter(n => n.show);
    
    if (selectedNode) {
      const activeSet = new Set([selectedNode.id, ...(adjacency.get(selectedNode.id) || [])]);
      const activeNodes = visibleNodes.filter(n => activeSet.has(n.id));
      for (let i = activeNodes.length - 1; i >= 0; i--) {
        const n = activeNodes[i];
        if (Math.hypot(n.x - x, n.y - y) <= n.r) return n;
      }
      const otherNodes = visibleNodes.filter(n => !activeSet.has(n.id));
      for (let i = otherNodes.length - 1; i >= 0; i--) {
        const n = otherNodes[i];
        if (Math.hypot(n.x - x, n.y - y) <= n.r) return n;
      }
    } else {
      for (let i = visibleNodes.length - 1; i >= 0; i--) {
        const n = visibleNodes[i];
        if (Math.hypot(n.x - x, n.y - y) <= n.r) return n;
      }
    }
    return null;
  }

  function updateCanvasCursor() {
    if (isDragging || isDraggingNode) {
      canvas.style.cursor = 'grabbing';
    } else if (zoomLevel > 1.0) {
      canvas.style.cursor = 'grab';
    } else {
      canvas.style.cursor = 'default';
    }
  }

  canvas.addEventListener('mousedown', (evt) => {
    const pos = getCanvasPos(evt);
    const n = findNodeAtPos(pos.x, pos.y);
    
    if (n) {
      // Start potential node drag with delay
      mouseDownNode = n;
      mouseDownTime = Date.now();
      
      dragDelayTimer = setTimeout(() => {
        if (mouseDownNode === n) {
          // Stop physics during drag
          if (simulation) simulation.stop();
          
          isDraggingNode = true;
          draggedNode = n;
          
          // Save unfixed position before dragging
          if (!n.isFixed) {
            n.unfixedX = n.x;
            n.unfixedY = n.y;
          }
          
          updateCanvasCursor();
          render();
        }
      }, CONFIG.dragDelayMs);
      
      evt.preventDefault();
    } else if (zoomLevel > 1.0) {
      // Panning canvas
      isDragging = true;
      dragStartX = evt.clientX;
      dragStartY = evt.clientY;
      dragStartPanX = panX;
      dragStartPanY = panY;
      updateCanvasCursor();
      evt.preventDefault();
    }
  });

  canvas.addEventListener('mousemove', (evt) => {
    if (isDraggingNode && draggedNode) {
      const pos = getCanvasPos(evt);
      draggedNode.x = pos.x;
      draggedNode.y = pos.y;
      render();
      evt.preventDefault();
    } else if (isDragging && zoomLevel > 1.0) {
      const deltaX = evt.clientX - dragStartX;
      const deltaY = evt.clientY - dragStartY;
      panX = dragStartPanX + deltaX / zoomLevel;
      panY = dragStartPanY + deltaY / zoomLevel;
      render();
      evt.preventDefault();
    } else {
      // Hover effect
      const pos = getCanvasPos(evt);
      const n = findNodeAtPos(pos.x, pos.y);
      if (n !== hoveredNode) {
        hoveredNode = n;
        render();
      }
    }
  });

  canvas.addEventListener('mouseup', (evt) => {
    // Clear drag delay timer
    if (dragDelayTimer) {
      clearTimeout(dragDelayTimer);
      dragDelayTimer = null;
    }
    
    if (isDraggingNode && draggedNode) {
      // Snap to grid
      const snapped = snapToGrid(draggedNode.x, draggedNode.y);
      draggedNode.x = snapped.x;
      draggedNode.y = snapped.y;
      
      // Auto-fix the node
      draggedNode.isFixed = true;
      draggedNode.fx = snapped.x;
      draggedNode.fy = snapped.y;
      
      markDirty();
      updateEntityTable();
      schedulePhysicsRestart();
      
      isDraggingNode = false;
      draggedNode = null;
      mouseDownNode = null;
      updateCanvasCursor();
      evt.preventDefault();
    } else if (isDragging) {
      const deltaX = Math.abs(evt.clientX - dragStartX);
      const deltaY = Math.abs(evt.clientY - dragStartY);
      
      isDragging = false;
      updateCanvasCursor();
      
      if (deltaX < 3 && deltaY < 3) {
        const pos = getCanvasPos(evt);
        const n = findNodeAtPos(pos.x, pos.y);
        if (n) {
          selectedNode = n;
          populateInfoPanel(n);
          updateEntityTable();
          render();
        } else {
          selectedNode = null;
          clearInfoPanel();
          updateEntityTable();
          render();
        }
      }
      evt.preventDefault();
    } else if (mouseDownNode) {
      // Quick click without drag
      const timeSinceDown = Date.now() - mouseDownTime;
      if (timeSinceDown < CONFIG.dragDelayMs) {
        const pos = getCanvasPos(evt);
        const n = findNodeAtPos(pos.x, pos.y);
        if (n && n === mouseDownNode) {
          selectedNode = n;
          populateInfoPanel(n);
          updateEntityTable();
          render();
        }
      }
      mouseDownNode = null;
    }
  });

  canvas.addEventListener('click', (evt) => {
    if (zoomLevel > 1.0 || isDragging || isDraggingNode) return;
    
    const pos = getCanvasPos(evt);
    const n = findNodeAtPos(pos.x, pos.y);
    if (n) {
      selectedNode = n;
      populateInfoPanel(n);
      updateEntityTable();
      render();
    } else {
      selectedNode = null;
      clearInfoPanel();
      updateEntityTable();
      render();
    }
  });

  canvas.addEventListener('mouseleave', (evt) => {
    if (dragDelayTimer) {
      clearTimeout(dragDelayTimer);
      dragDelayTimer = null;
    }
    
    isDragging = false;
    if (isDraggingNode) {
      // Restart physics if we were dragging
      schedulePhysicsRestart();
    }
    isDraggingNode = false;
    draggedNode = null;
    mouseDownNode = null;
    updateCanvasCursor();
    if (hoveredNode) {
      hoveredNode = null;
      render();
    }
  });

  /************************************************************************
   * ZOOM CONTROLS
   ************************************************************************/
  function zoomIn() {
    zoomLevel = Math.min(CONFIG.zoomMax, zoomLevel + CONFIG.zoomStep);
    updateCanvasCursor();
    render();
  }
  
  function zoomOut() {
    zoomLevel = Math.max(CONFIG.zoomMin, zoomLevel - CONFIG.zoomStep);
    updateCanvasCursor();
    render();
  }
  
  function resetZoom() {
    zoomLevel = 1.0;
    panX = 0;
    panY = 0;
    updateCanvasCursor();
    render();
  }

  zoomInBtn.addEventListener('click', zoomIn);
  zoomOutBtn.addEventListener('click', zoomOut);
  zoomResetBtn.addEventListener('click', resetZoom);

  /************************************************************************
   * INFO PANEL
   ************************************************************************/
  function normalizeUrl(u) {
    if (!u) return null;
    const s = String(u).trim();
    if (s === '') return null;
    if (/^[a-zA-Z][a-zA-Z0-9+\-.]*:\/\//.test(s)) return s;
    return 'https://' + s.replace(/^[\/]+/, '');
  }

  function populateInfoPanel(d) {
    const desc = (d.raw && (d.raw['Description'] || '')) || '';
    const category = (d.raw && (d.raw['Category'] || '')) || '';

    // Build the links FIRST
    const rawLink = (d.raw && (d.raw['Link'] || d.raw['Link '])) || '';
    const safe = normalizeUrl(rawLink);
    const rawMoreInfo = (d.raw && (d.raw['More Info'] || d.raw['More Info'])) || '';
    const safeMoreInfo = normalizeUrl(rawMoreInfo);

    let links = [];
    if (safe) links.push(`<a href="${safe}" target="_blank" rel="noopener">More Info</a>`);
    if (safeMoreInfo) links.push(`<a href="${safeMoreInfo}" target="_blank" rel="noopener">More Info</a>`);
    const linksHTML = links.length > 0 ? links.join(' | ') : '';

    // Now set the title area INCLUDING the links
    nodeTitleEl.html(`
      <div style="display:flex; align-items:center; gap:8px; font-size:24px; font-weight:700;">
        <span>${d.name}</span>
        ${d.image ? `<img src="${d.image}" style="width:40px; height:40px; object-fit:cover; border-radius:50%;">` : ''}
      </div>
      ${category ? `<div style="font-size: 15px; font-weight: bold; margin-top: 6px;">${category.replace(/\n/g, '<br>')}</div>` : ''}
      ${desc ? `<div style="font-size: 13px; font-weight: normal;">${desc}</div>` : ''}
      ${linksHTML ? `<div style="margin-top: 8px;">${linksHTML}</div>` : ''}
      <div style="font-size: 14px; font-weight: bold; margin-top: 6px;">
        <br>
        <br>Connected to: 
      </div>
    `);

    // Clear the old nodeLinkEl since we're not using it anymore
    nodeLinkEl.html('');

    const conns = Array.from(adjacency.get(d.id) || []).slice();
    conns.sort((a,b) => a.localeCompare(b, undefined, {sensitivity:'base'}));
    connectionsBox.innerHTML = '';
    if (conns.length === 0) {
      connectionsBox.innerHTML = '<div class="muted">No connections</div>';
      return;
    }
    const frag = document.createDocumentFragment();
    const nodeSourceMap = connectionSources.get(d.id);
    conns.forEach(name => {
      const item = document.createElement('div');
      item.className = 'conn-item';
      item.style.display = 'flex';
      item.style.alignItems = 'center';
      item.style.justifyContent = 'space-between';
      item.style.gap = '8px';
      
      const nameSpan = document.createElement('span');
      nameSpan.textContent = name;
      nameSpan.style.flex = '1';
      nameSpan.style.cursor = 'pointer';
      nameSpan.addEventListener('click', () => {
        const targetNode = nodeById.get(name);
        if (targetNode) {
          selectedNode = targetNode;
          populateInfoPanel(targetNode);
          updateEntityTable();
          render();
          connectionsBox.scrollTop = 0;
        }
      });
      item.appendChild(nameSpan);
      
      const sourceUrl = nodeSourceMap ? nodeSourceMap.get(name) : null;
      if (sourceUrl) {
        const sourceIcon = document.createElement('a');
        sourceIcon.href = normalizeUrl(sourceUrl) || '#';
        sourceIcon.target = '_blank';
        sourceIcon.rel = 'noopener';
        sourceIcon.innerHTML = '🔗';
        sourceIcon.style.fontSize = '16px';
        sourceIcon.style.textDecoration = 'none';
        sourceIcon.style.cursor = 'pointer';
        sourceIcon.style.flexShrink = '0';
        sourceIcon.title = 'View source';
        sourceIcon.addEventListener('click', (e) => {
          e.stopPropagation();
        });
        item.appendChild(sourceIcon);
      }
      
      frag.appendChild(item);
    });
    connectionsBox.appendChild(frag);
  }

  function clearInfoPanel() {
    nodeTitleEl.html('Select a node to view details');
    nodeMetaEl.text('');
    nodeLinkEl.html('');
    connectionsBox.innerHTML = '';
  }

  searchInput.addEventListener('input', onSearchInput);
  searchBtn.addEventListener('click', () => performSearch(searchInput.value.trim()));
  searchInput.addEventListener('keydown', (ev) => { 
    if (ev.key === 'Enter') { 
      performSearch(searchInput.value.trim()); 
      ev.preventDefault(); 
    } 
  });

  clearBtn.addEventListener('click', () => { 
    selectedNode = null; 
    clearInfoPanel(); 
    updateEntityTable();
    render(); 
    searchInput.value = ''; 
    suggestionsEl.style('display', 'none').html(''); 
    msgEl.text('');
  });

  function onSearchInput() {
    const q = searchInput.value.trim();
    suggestionsEl.style('display', 'none').html('');
    msgEl.text('');
    if (!q || q.length < 3) return;
    const term = q.toLowerCase();
    const matches = [];
    for (const name of nameIndex) {
      if (name && name.toLowerCase().includes(term)) matches.push(name);
      if (matches.length >= CONFIG.maxSuggestions) break;
    }
    if (matches.length === 0) {
      suggestionsEl.style('display','block').html('<div class="muted">No suggestions</div>');
      return;
    }
    suggestionsEl.style('display','block').html('');
    matches.forEach(m => {
      suggestionsEl.append('div').attr('class','suggestion').text(m).on('click', () => {
        searchInput.value = m;
        suggestionsEl.style('display','none').html('');
        performSearch(m);
      });
    });
  }

  function performSearch(q) {
    if (!q) return;
    const exact = nodes.find(n => n.name && n.name.toLowerCase() === q.toLowerCase());
    if (exact) {
      selectedNode = exact; 
      populateInfoPanel(exact); 
      updateEntityTable();
      render(); 
      msgEl.text(''); 
      return;
    }
    const matches = nodes.filter(n => n.name && n.name.toLowerCase().includes(q.toLowerCase()));
    if (matches.length === 1) {
      selectedNode = matches[0]; 
      populateInfoPanel(matches[0]); 
      updateEntityTable();
      render(); 
      msgEl.text(''); 
      return;
    } else if (matches.length > 1) {
      suggestionsEl.style('display','block').html('');
      matches.slice(0, CONFIG.maxSuggestions).forEach(m => {
        suggestionsEl.append('div').attr('class','suggestion').text(m.name).on('click', () => {
          searchInput.value = m.name;
          suggestionsEl.style('display','none').html('');
          selectedNode = m;
          populateInfoPanel(m);
          updateEntityTable();
          render();
        });
      });
      msgEl.text('Multiple matches — click a suggestion.'); 
      return;
    } else {
      msgEl.text('Search term not found. Please try again.');
    }
  }

  /************************************************************************
   * KEYBOARD SHORTCUTS
   ************************************************************************/
  document.addEventListener('keydown', (e) => {
    // Ctrl+S / Cmd+S to download
    if ((e.ctrlKey || e.metaKey) && e.key === 's') {
      e.preventDefault();
      handleDownload();
    }
    
    // Escape to close confirm dialog
    if (e.key === 'Escape') {
      closeConfirmDialog();
    }
  });

  /************************************************************************
   * INITIAL RENDER
   ************************************************************************/
  render();
  </script>
</body>
</html>