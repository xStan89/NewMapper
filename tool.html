<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Research Tool</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Rubik:wght@400;700&display=swap');
    
    :root {
      --text-black: #020202;
      --near-black: #383838;
      --bg-white: #d3d3d3;
      --panel-grey: #C2C2C2;
      --main-yellow: #FFD241;
      --shadow-grey: #9E9E9E;
      --light-yellow: #FFEDB4;
      --shadow-yellow: #DEB555;
      --light-grey:  #d8d8d8;
      --highlight-white: #FFFFFF;
      --error-red: #dc2626;
      --font-family: 'Rubik', Arial, Helvetica, sans-serif;
    }
    
    html,body { 
      height:100%; 
      margin:0; 
      font-family: var(--font-family); 
      background:var(--bg-white); 
    }
    #wrap { display:flex; height:100vh; overflow:hidden; }

    /* ENTITY MANAGER PANEL (LEFT) */
    #entity-manager {
      width: 292px;
      min-width: 292px;
      background: var(--panel-grey);
      color: var(--text-black);
      padding: 16px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      border-right: 1px solid var(--shadow-grey);
      font-size: 13px;
      overflow: hidden;
    }

    .manager-section {
      margin-bottom: 16px;
    }
    
    .manager-section h3 {
      margin: 0 0 8px 0;
      font-size: 14px;
      font-weight: 700;
      opacity: 0.7;
    }
    
    .upload-area {
      border: 2px dashed var(--shadow-grey);
      border-radius: 8px;
      padding-top: 8px;
      padding-left: 3px;
      padding-right: 3px;
      padding-bottom: 0px;
      text-align: center;
      background: var(--light-grey);
    }
    
    .button-row {
      display: grid;
      grid-template-columns: repeat(4, 0fr);
      gap: 0px;
      margin-bottom: 4px;
      margin-top: 4px;
      justify-content: center;
    }
    
    .icon-btn {
      flex: 1;
      padding: 0px;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      font-family: var(--font-family);
      font-size: 12px;
      transition: all 0.2s;
    }
    
    .add-btn {
      background: var(--light-grey);
      color: var(--text-black);
    }
    
    .add-btn:hover {
      background: var(--light-yellow);
    }

    .upload-btn {
      background: var(--light-grey);
      color: var(--text-black);
    }
    
    .upload-btn:hover {
      background: var(--light-yellow);
    }
    
    .download-btn {
      background: var(--light-grey);
      color: var(--highlight-white);
    }
    
    .download-btn:hover {
      background: var(--light-yellow);
    }
    
    /* .download-btn.unsaved {
      background: rgba(70,248,128,0.2);
      animation: pulse 2s infinite;
    } */
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    @keyframes pulseGlow {
      50%, 100% { 
        box-shadow: 0 0 7px 2px rgba(255, 210, 65, 0.8);
      }
      50% { 
        box-shadow: 0 0 15px 5px rgba(255, 210, 65, 1);
      }
    }
    
    #file-input, #file-input-add {
      display: none;
    }
    
    .status-msg {
      margin-top: 0px;
      margin-bottom: 8px;
      font-size: 11px;
      color: var(--text-black);
      min-height: 14px;
      font-weight: 700;
    }
    
    .status-msg.error {
      color: var(--error-red);
    }

    /* TAB BUTTONS */
    .tab-buttons {
      display: flex;
      gap: 2px;
      margin-bottom: 0px;
    }
    
    .tab-btn {
      flex: 1;
      font-family: var(--font-family);
      color: var(--near-black);
      background: var(--light-grey);
      border: 1px solid var(--shadow-grey);
      border-bottom: none;
      border-radius: 8px 8px 0 0;
      padding-top: 4px;
      padding-bottom: 4px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    
    .tab-btn img {
      width: 24px;
      height: 24px;
      display: block;
    }
    
    .tab-btn:hover {
      background: var(--light-grey);
    }
    
    .tab-btn.active {
      font-weight: bold;
      color: var(--text-black);
      background: var(--shadow-grey);
      border-color: var(--shadow-grey);
      border-bottom: 1px solid var(--shadow-grey);
      z-index: 1;
    }
    
    /* FORMATTING MENU */
    #formatting-menu {
      flex: 1;
      overflow-y: auto;
      display: none;
      flex-direction: column;
      background: var(--light-grey);
      border-radius: 0 0 10px 10px;  /* No top-left radius */
      border: 1px solid var(--shadow-grey);
      padding: 0px;
    }

    .format-header {
      display: grid;
      gap: 0px;
      padding-top: 13px;
      padding-bottom: 12px;
      padding-left: 4px;
      padding-right: 4px;
      width: 258px;
      height: 42px;
      background: var(--shadow-grey);
      border-bottom: 1px solid var(--text-black);
      font-weight: 700;
      font-size: 11px;
      font-family: var(--font-family);
      align-items: left;
      justify-content: center;
      position: sticky; top: 0;
      z-index: 10; /* or higher */
      background: var(--shadow-grey); /* important: ensures solid cover */
    }
    
    .format-control input[type="color"] {
      width: 73px;
      height: 32px;
      margin-left: 10px;
      margin-right: 10px;
      border: 1px solid var(--shadow-grey);
      border-radius: 4px;
      cursor: pointer;
    }
    
    .format-control input[type="number"] {
      width: 60px;
      padding: 6px;
      margin-left: 10px;
      margin-right: 10px;
      border: 1px solid var(--shadow-grey);
      border-radius: 4px;
      font-family: var(--font-family);
      font-size: 12px;
    }

    .format-subheader {
      font-size: 14px;
      font-weight: 700;
      text-transform: uppercase;
      color: solid var(--near-black);
      margin-bottom: 6px;
      border-bottom: 1px solid var(--shadow_grey);
      padding-top: 12px;
      padding-left: 8px;
      padding-bottom: 2px;
    }

    .format-divider {
      border: none;
      border-top: 1px solid var(--shadow-grey);
      margin: 12px 0;
    }

    .format-control {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 6px 0;
    }

    .format-control label {
      font-size: 13px;
      color: var(--text-black);
      padding-left: 16px;
    }

    .format-control input {
      margin-left: 8px;
    }

    /* ENTITY TABLE */
    #entity-table-container {
      flex: 1;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      background: var(--light-grey);
      border-radius: 0 0px 10px 10px;  /* No top-left radius */
      border: 1px solid var(--shadow-grey);
    }
    
    .table-header {
      display: grid;
      grid-template-columns: 1fr 60px 20px;
      gap: 6px;
      padding-top: 4px;
      padding-bottom: 0px;
      padding-left: 8px;
      padding-right: 10px;
      background: var(--shadow-grey);
      border-bottom: 1px solid var(--text-black);
      font-weight: 700;
      font-size: 11px;
      text-transform: uppercase;
      align-items: center;
    }
    
    .show-controls {
      display: flex;
      flex-direction: column; /* Stack vertically */
      gap: 4px;
      /* justify-content: center; */
      align-items: center;
    }
    
    /* new helper for the two buttons to sit horizontally */
    .show-buttons {
      display: flex;
      flex-direction: row;
      gap: 4px;
      align-items: center;
    }

    .show-toggle-btn {
      background: var(--main-yellow);
      color: var(--text-black);
      border: none;
      border-radius: 3px;
      padding: 2px 4px;
      cursor: pointer;
      font-size: 9px;
      font-family: var(--font-family);
      font-weight: 700;
    }
    
    .show-toggle-btn:hover {
      background: var(--light-yellow);
      color: var(--text-black);
    }
    
    #entity-table {
      flex: 1;
      overflow-y: auto;
      padding: 4px;
    }
    
    .entity-row {
      display: grid;
      grid-template-columns: 1fr 64px 20px;
      gap: 4px;
      padding: 6px 6px;
      border-bottom: 1px solid rgba(0,0,0,0.1);
      align-items: center;
    }
    
    .entity-row:hover {
      background: rgba(255,255,255,0.5);
    }
    
    .entity-row.selected {
      background: var(--light-yellow);
    }
    
    .entity-name {
      cursor: pointer;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      font-size: 12px;
    }
    
    .entity-name:hover {
      color: var(--shadow-yellow);
    }
    
    .entity-checkbox {
      width: 16px;
      height: 16px;
      cursor: pointer;
      margin: 0 auto;
      display: block;
    }
    
    .empty-state {
      padding: 40px 20px;
      text-align: center;
      color: var(--shadow-grey);
    }

    /* GRAPH AREA */
    #graph-area { position:relative; flex:1; background:var(--bg-white); }
    canvas { width:100%; height:100%; display:block; background:var(--bg-white); }

    /* LOGO */
    #logo {
      position: absolute;
      bottom: 6px;
      right: 16px;
      z-index: 10;
      opacity: 1;
      pointer-events: none;
    }
    
    #logo img {
      height: 70px;
      width: auto;
    }

    /* TOP CONTROLS - ZOOM */
    #top-controls {
      position: absolute;
      top: 12px;
      right: 12px;
      display: flex;
      gap: 12px;
      z-index: 10;
    }

    #zoom-controls {
      display: flex;
      gap: 8px;
    }
    
    .zoom-btn {
      padding: 6px 8px;
      border-radius: 20px;
      border: none;
      cursor: pointer;
      background: var(--panel-grey);
      color: var(--text-black);
      font-size: 18px;
      font-weight: bold;
      min-width: 35px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: var(--font-family);
    }
    
    .zoom-btn:hover {
      background: var(--light-yellow);
    }

    /* INFO PANEL (RIGHT) */
    #info-panel {
      width: 292px;
      min-width: 292px;
      max-width: 292px;
      background: var(--panel-grey);
      color: var(--text-black);
      padding: 12px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      border-left: 1px solid var(--shadow-grey);
      font-size: 13px;
      height: 100vh;
      overflow: hidden;
    }
    
    #controls { 
      display: flex; 
      gap: 8px; 
      align-items: center; 
      flex-shrink: 0; 
      margin-bottom: 8px;
    }
    #search-box { display: flex; width: 100%; gap: 6px; flex-wrap: wrap; }
    #search-input { 
      flex: 1; 
      min-width: 0;
      padding: 6px 8px; 
      border-radius: 4px; 
      border: 1px solid var(--shadow-grey); 
      background: rgba(255,255,255,0.5); 
      color: var(--text-black);
      font-family: var(--font-family); 
    }
    #search-btn, #clear-btn { 
      padding: 8px 8px; 
      border-radius: 4px; 
      border: none; 
      cursor: pointer; 
      background: var(--main-yellow); 
      color: var(--text-black);
      font-family: var(--font-family);
      font-weight: bold;
      flex-shrink: 0;
      white-space: nowrap;
    }
    
    #search-btn:hover, #clear-btn:hover {
      background: var(--light-yellow);
    }

    #suggestions { 
      background: rgba(255,255,255,0.5); 
      border: 1px solid var(--shadow-grey); 
      max-height: 160px; 
      overflow: auto; 
      display: none; 
      padding: 6px; 
      border-radius: 4px; 
    }
    .suggestion { 
      padding: 6px; 
      cursor: pointer; 
      border-bottom: 1px dashed var(--shadow-grey); 
    }
    .suggestion:hover { 
      background: var(--light-yellow); 
    }

    #node-info { 
      margin-top: 8px; 
      padding: 8px; 
      background: var(--panel-grey); 
      border-radius: 6px; 
      flex-shrink: 0;
    }
    #node-title { font-weight: 700; }
    .muted { color: var(--shadow-grey); font-weight: 700; }

    #node-links {
      margin-top: 8px;
      flex-shrink: 0;
    }

    #connections-box {
      margin-top: -6px;
      background: var(--light-grey);
      border-radius: 6px;
      padding: 6px;
      overflow: auto;
      border: 1px solid var(--shadow-grey);
      flex: 1;
      min-height: 0;
    }
    .conn-item {
      padding: 6px;
      cursor: pointer;
      font-size: 13px;
      color: var(--text-black);
      border-bottom: 1px dashed var(--shadow-grey);
    }
    .conn-item:hover { 
      background: var(--light-yellow); 
    }

    #msg { margin-top: 6px; color: var(--error-red); font-size: 13px; min-height: 18px; }

    /* LOADING OVERLAY */
    #loading-overlay {
      position: fixed;
      left: 0;
      top: 0;
      right: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 10px;
      background: rgba(250,250,250,0.9);
      z-index: 99999;
      font-size: 16px;
      color: var(--text-black);
    }
    .spinner {
      width: 64px;
      height: 64px;
      border-radius: 50%;
      border: 8px solid var(--shadow-grey);
      border-left-color: var(--main-yellow);
      animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* CONFIRM DIALOG */
    #confirm-dialog {
      position: fixed;
      left: 0;
      top: 0;
      right: 0;
      bottom: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.5);
      z-index: 100000;
    }
    
    .confirm-box {
      background: var(--highlight-white);
      border: 2px solid var(--text-black);
      border-radius: 8px;
      padding: 24px;
      max-width: 400px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    
    .confirm-message {
      font-size: 16px;
      margin-bottom: 20px;
      color: var(--text-black);
      font-weight: 600;
    }
    
    .confirm-buttons {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
    }
    
    .confirm-btn {
      padding: 8px 20px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-family: var(--font-family);
      font-weight: 600;
      font-size: 14px;
    }
    
    .confirm-yes {
      background: var(--error-red);
      color: white;
    }
    
    .confirm-yes:hover {
      background: #b91c1c;
    }
    
    .confirm-no {
      background: var(--shadow-grey);
      color: white;
    }
    
    .confirm-no:hover {
      background: var(--text-black);
    }

    /* EXPORT CONTROLS */
    #export-controls {
      position: fixed ;
      display: none;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 12px;
      background: var(--highlight-white);
      border: 2px solid var(--text-black);
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      z-index: 1000;
    }
    
    .export-control-btn {
      padding: 10px 20px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-family: var(--font-family);
      font-weight: 700;
      font-size: 13px;
      transition: all 0.2s;
      white-space: nowrap;
    }
    
    .export-control-btn.export {
      background: var(--main-yellow);
      color: var(--text-black);
    }
    
    .export-control-btn.export:hover {
      background: var(--shadow-yellow);
    }
    
    .export-control-btn.redraw {
      background: var(--panel-grey);
      color: var(--text-black);
    }
    
    .export-control-btn.redraw:hover {
      background: var(--shadow-grey);
    }
    
    .export-control-btn.cancel {
      background: var(--error-red);
      color: white;
    }
    
    .export-control-btn.cancel:hover {
      background: #b91c1c;
    }

    /* EXPORT OPTIONS MODAL */
    #export-options-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }
    
    .export-options-box {
      background: var(--highlight-white);
      border: 2px solid var(--text-black);
      border-radius: 8px;
      padding: 24px;
      max-width: 500px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    
    .export-options-title {
      font-size: 18px;
      margin-bottom: 20px;
      color: var(--text-black);
      font-weight: 700;
    }
    
    .export-options-content {
      font-size: 14px;
      color: var(--text-black);
      margin-bottom: 20px;
    }

    /* Disabled overlay */
    .disabled-overlay {
      opacity: 0.5;
      pointer-events: none;
    }

    /* responsive */
    @media (max-width: 1200px) { 
      #entity-manager { width: 280px; min-width: 280px; }
      #entity-toggle.panel-open { left: 280px; }
      #info-panel { width: 280px; min-width: 280px; max-width: 280px; } 
    }
  </style>
</head>
<body>
  <div id="wrap">
    
    <aside id="entity-manager">
      <div class="manager-section">
        <div class="upload-area">
          <br>
          <p style="margin: 0 0 8px 0; opacity: 0.7; font-size: 13px;">
            <a href="https://docs.google.com/presentation/d/e/2PACX-1vRNfGtXRnwofGlAjKaeIbvKVWtlvpLfEK72sobg8WMamiZ9akXBC97C6PWJQstHp7iCLk-WPgSvlS9k/pub?start=false&loop=false&delayms=30000" target="_blank" style="color: inherit; text-decoration: underline;">
              Learn how to start using this tool
            </a>
          </p>

          <input type="file" id="file-input" accept=".csv" multiple />
          <input type="file" id="file-input-add" accept=".csv" multiple />

          <div class="button-row">
            <button class="icon-btn upload-btn" onclick="document.getElementById('file-input').click()" title="Upload/Replace Data">
              <img src="https://i.ibb.co/Y4QvYnZ1/UPicon.png" alt="Upload/Replace Data" style="width:60px; height:60px;">
            </button>
            <button class="icon-btn add-btn" onclick="document.getElementById('file-input-add').click()" title="Add to Current Data">
              <img src="https://i.ibb.co/b5mC25yP/ADDicon.png" alt="Add to Current Data" style="width:60px; height:60px;">
            </button>
            <button class="icon-btn download-btn" id="download-btn" onclick="handleDownload()" title="Download CSVs">
              <img src="https://i.ibb.co/99NngYsW/DOWNicon.png" alt="Download CSVs" style="width:60px; height:60px;">
            </button>
            <button class="icon-btn download-btn" id="export-chart-btn" onclick="startExportMode()" title="Export Chart">
              <img src="https://i.ibb.co/7Jk1sJ4S/img-332231.png" alt="Export Chart" style="width:55px; height:55px;">
            </button>
          </div>

          <div class="status-msg" id="status-msg"></div>
        </div>
      </div>
      
      <div class="manager-section" style="flex: 1; display: flex; flex-direction: column; min-height: 0;">
        <div class="tab-buttons">
          <button class="tab-btn active" id="entities-tab" title="Entities List">
            Entities List
          </button>
          <button class="tab-btn" id="formatting-tab" title="Formatting Menu">
            Formatting
          </button>
        </div>
        
        <div id="entity-table-container">
          <div class="table-header">
            <div>Name</div>
              <div class="show-controls">
                <span style="font-size: 10px;">Show</span>
                <div class="show-buttons">
                  <button class="show-toggle-btn" onclick="toggleAllShow(true)" title="Show All">All</button>
                  <button class="show-toggle-btn" onclick="toggleAllShow(false)" title="Hide All">None</button>
                </div>
              </div>
            <div style="text-align: center;">Fix</div>
            <div></div>
          </div>
          <div id="entity-table">
            <div class="empty-state">
              Upload CSVs to get started
            </div>
          </div>
        </div>
        
        <div id="formatting-menu">
          <div class="format-header">
            <select id="format-rule-selector" style="width: 100%; height: 100%; border: none; background: var(--shadow-grey); color: var(--text-black); font-family: var(--font-family); font-size: 14px; font-weight: 700; text-align: center; cursor: pointer; padding: 0 30px 0 10px; appearance: none; background-image: url('data:image/svg+xml;utf8,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 12 8%22><path fill=%22%23020202%22 d=%22M0 0l6 8 6-8z%22/></svg>'); background-repeat: no-repeat; background-position: right 10px center; background-size: 10px;">
              <option value="default">DEFAULT FORMAT</option>
              <optgroup label="───────────────" disabled></optgroup>
              <option value="create-entity">+ Create a new Entity rule</option>
              <option value="create-category">+ Create a new Category rule</option>
            </select>
          </div>
          <div id="rule-controls" style="display: none; padding: 8px; background: var(--light-grey); border-bottom: 1px solid var(--shadow-grey); flex-direction:row-reverse ; gap: 4px; ">
            <button id="rule-delete-btn" style="width: 30px; padding: 6px 12px; border: none; border-radius: 4px; cursor: pointer; font-family: var(--font-family); font-size: 11px; font-weight: 600; background: var(--error-red); color: white;" title="Delete Rule">×</button>
            <button id="rule-down-btn" style="width: 30px; padding: 6px 9px; border: none; border-radius: 4px; cursor: pointer; font-family: var(--font-family); font-size: 11px; font-weight: 600; background: var(--panel-grey); color: var(--text-black);" title="Move Rule Down">▼</button>
            <button id="rule-up-btn" style="width: 30px; padding: 6px 9px; border: none; border-radius: 4px; cursor: pointer; font-family: var(--font-family); font-size: 11px; font-weight: 600; background: var(--panel-grey); color: var(--text-black);" title="Move Rule Up">▲</button>
            <label style="display: block; font-size: 11px; padding-top: 6px; padding-right: 6px; font-family: var(--font-family); color: var(--shadow-grey);">Rule controls:</label>
          </div>
          
          <!-- Rule Name Input (shown when creating/editing a rule) -->
          <div id="rule-name-section" style="display: none; padding: 12px; background: var(--light-grey); border-bottom: 1px solid var(--shadow-grey);">
            <label style="display: block; font-size: 11px; font-weight: 700; margin-bottom: 4px; font-family: var(--font-family); color: var(--near-black);">RULE NAME</label>
            <input type="text" id="rule-name-input" placeholder="Enter rule name" style="width: 100%; padding: 8px; border: 1px solid var(--shadow-grey); border-radius: 4px; font-family: var(--font-family); font-size: 13px; box-sizing: border-box; ">
          </div>
          
          <!-- Target Selection (shown when creating/editing entity/category rules) -->
          <div id="rule-targets-section" style="display: none; padding: 12px; background: var(--light-grey); border-bottom: 1px solid var(--shadow-grey);">
            <label style="display: block; font-size: 11px; font-weight: 700; margin-bottom: 4px; font-family: var(--font-family); color: var(--near-black);" id="rule-targets-label">TARGETS</label>
            <input type="text" id="rule-targets-search" placeholder="Search..." style="width: 100%; padding: 8px; border: 1px solid var(--shadow-grey); border-radius: 4px; font-family: var(--font-family); font-size: 13px; box-sizing: border-box; margin-bottom: 8px;">
            <div id="rule-targets-list" style="max-height: 150px; overflow-y: auto; border: 1px solid var(--shadow-grey); border-radius: 4px; background: white; padding: 4px; margin-bottom: 8px;"></div>
            <div id="rule-selected-targets" style="display: flex; flex-wrap: wrap; gap: 6px;"></div>
          </div>
          
          <div class="format-section">
          <h3 class="format-subheader">Node</h3>
          <div class="format-control">
            <label>Color</label>
            <input type="color" id="fmt-node-color" value="#000000">
          </div>
          <div class="format-control" id="node-hover-color-control">
            <label>Hover Color</label>
            <input type="color" id="fmt-node-hover-color" value="#FFD241">
          </div>
          <h3 class="format-subheader">Node Outline</h3>
          <div class="format-control">
            <label>Color</label>
            <input type="color" id="fmt-outline-color" value="#dadada">
          </div>
          <div class="format-control" id="outline-hover-color-control">
            <label>Hover Color</label>
            <input type="color" id="fmt-outline-hover-color" value="#FFD241">
          </div>
          <div class="format-control">
            <label>Thickness</label>
            <input type="number" id="fmt-outline-thickness" value="4" min="0" max="10" step="0.5">
          </div>
          <div class="format-control" id="outline-hover-thickness-control">
            <label>Hover Thickness</label>
            <input type="number" id="fmt-outline-hover-thickness" value="5" min="0" max="10" step="0.5">
          </div>
          <h3 class="format-subheader">Node Size</h3>
          <div class="format-control" id="size-mode-control">
            <label>Size Mode</label>
            <select id="fmt-size-mode" style="padding: 6px; margin-right: 10px; border: 1px solid var(--shadow-grey); border-radius: 4px; font-family: var(--font-family); font-size: 12px;">
              <option value="connections"># of Connections</option>
              <option value="custom">Custom Size</option>
            </select>
          </div>
          <div class="format-control" id="custom-size-checkbox-control" style="display: none;">
            <label>Custom Size</label>
            <input type="checkbox" id="fmt-custom-size-enabled" style="margin-right: 10px;">
          </div>
          <div class="format-control" id="custom-size-control" style="display: none;">
            <label>Custom Size (px)</label>
            <input type="number" id="fmt-custom-size" min="5" max="100" value="20">
          </div>
          <div class="format-control" id="min-size-control">
            <label>Min Size (px)</label>
            <input type="number" id="fmt-min-size" min="1" max="50" value="5">
          </div>
          <div class="format-control" id="max-size-control">
            <label>Max Size (px)</label>
            <input type="number" id="fmt-max-size" min="10" max="200" value="100">
          </div>
          <div class="format-control" id="size-scale-control">
            <label>Size Scale: <span id="scale-value">1.0x</span></label>
            <input type="range" id="fmt-size-scale" min="0" max="100" step="1" value="50" style="width: 120px; margin-right: 10px;">
          </div>
        </div>

        <hr class="format-divider">

        <div class="format-section">
          <h3 class="format-subheader">Connection Line</h3>
          <div class="format-control">
            <label>Color</label>
            <input type="color" id="fmt-line-color" value="#000000">
          </div>
          <div class="format-control" id="line-hover-color-control">
            <label>Hover Color</label>
            <input type="color" id="fmt-line-hover-color" value="#FFD241">
          </div>
          <div class="format-control">
            <label>Thickness</label>
            <input type="number" id="fmt-line-thickness" value="3" min="0.5" max="10" step="0.5">
          </div>
          <div class="format-control" id="line-hover-thickness-control">
            <label>Hover Thickness</label>
            <input type="number" id="fmt-line-hover-thickness" value="5" min="0.5" max="10" step="0.5">
          </div>
        </div>

        <hr class="format-divider" id="other-options-divider">

        <div class="format-section" id="other-options-section">
          <h3 class="format-subheader">Other Options</h3>
          <div class="format-control">
            <label>Background Color</label>
            <input type="color" id="fmt-bg-color" value="#dadada">
          </div>          
          <br></br>
          <div class="format-control">
            <label>Is something missing??  Contact Matt!</label>
          </div>
          <br></br>
        </div>
        </div>
      </div>
    </aside>
    
    <div id="graph-area">
      <canvas id="canvas"></canvas>
      
      <div id="logo">
        <img src="https://i.ibb.co/wFQj75cn/De-Smog-Data-Tools.png" alt="Logo">
      </div>
      
      <div id="top-controls">
        <div id="zoom-controls">
          <button id="zoom-in" class="zoom-btn" title="Zoom In">+</button>
          <button id="zoom-out" class="zoom-btn" title="Zoom Out">−</button>
          <button id="zoom-reset" class="zoom-btn" title="Reset Zoom">↻</button>
        </div>
      </div>

      <div id="loading-overlay" style="display: none;">
        <div class="spinner"></div>
        <div id="loading-text">Processing...</div>
      </div>
    </div>

    <aside id="info-panel">
      <div id="controls">
        <div id="search-box">
          <input id="search-input" placeholder="Search..." />
          <button id="search-btn">Search</button>
        </div>
      </div>

      <button id="clear-btn" style="margin-bottom: 8px; flex-shrink: 0;">Clear Selection</button>

      <div id="suggestions"></div>

      <div id="node-info">
        <div id="node-title">Select an entity to view details</div>
        <div id="node-meta" class="muted" style="margin-top:6px;"></div>
      </div>

      <div id="node-links"></div>

      <div id="connections-box"></div>

      <div id="msg"></div>
    </aside>
  </div>

  <!-- Confirm Dialog -->
  <div id="confirm-dialog">
    <div class="confirm-box">
      <div class="confirm-message" id="confirm-message">Are you sure?</div>
      <div class="confirm-buttons">
        <button class="confirm-btn confirm-no" id="confirm-no">Cancel</button>
        <button class="confirm-btn confirm-yes" id="confirm-yes">Confirm</button>
      </div>
    </div>
  </div>

  <!-- Export Controls -->
  <div id="export-controls">
    <button style="width: 200px" class="export-control-btn export" onclick="showExportOptions()">CREATE EMBED CODE</button>
    <button style="width: 200px" class="export-control-btn redraw" onclick="redrawBorder()">RE-DRAW BORDER</button>
    <button style="width: 200px" class="export-control-btn cancel" onclick="cancelExport()">CANCEL EXPORT</button>
  </div>

  <!-- Export Options Modal -->
  <div id="export-options-modal">
    <div class="export-options-box">
      <div class="export-options-title">Export Options</div>
      <div class="export-options-content">
        <label>Embed options TBD</label>
      </div>
      <div class="confirm-buttons">
        <button class="confirm-btn confirm-no" onclick="closeExportOptions()">Close</button>
      </div>
    </div>
  </div>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
  <script>
  /************************************************************************
   * CONFIG
   ************************************************************************/
  const CONFIG = {
    colorPalette: d3.schemeTableau10,
    pointOpacity: 1.0,
    unconnectedOpacity: 0.15,
    linkOpacityNoSelection: 0.8,
    linkOpacitySelected: 0.8,
    labelFontSize: 17,
    labelBoxPadding: 4,
    labelOffsetY: 4,
    labelBoxOpacity: 0.6,
    gridSize: 25,
    dragDelayMs: 600, // hold before drag
    force: {
      linkDistance: 30,
      linkStrength: 0.8,
      chargeStrength: -300,
      collisionPadding: 10,
      velocityDecay: 0.1
    },
    showImages: true,
    maxSuggestions: 25, //what is this?
    zoomMin: 0.2,
    zoomMax: 5.0,
    zoomStep: 0.2
  };

  const PADDING = 80;

  // Default Formatting Settings that can be customized by user
  let formattingSettings = {
    nodeColor: '#000000',
    nodeHoverColor: '#FFD241',
    outlineColor: '#E3E3E3',
    outlineHoverColor: '#FFD241',
    outlineThickness: 4,
    outlineHoverThickness: 5,
    lineColor: '#000000',
    lineHoverColor: '#FFD241',
    lineThickness: 3,
    lineHoverThickness: 5,
    backgroundColor: '#E3E3E3',
    nodeSizeMode: 'connections', // 'connections' or 'custom'
    customNodeSize: 30,
    minNodeSize: 15,
    maxNodeSize: 80,
    sizeScale: 1.0
  };

  // Global state
  let nodes = [];
  let animationTime = 0;
  let links = [];
  let nodeById = new Map();
  let adjacency = new Map();
  let connectionSources = new Map();
  let nameIndex = [];
  let simulation = null;
  let selectedNode = null;
  let hoveredNode = null;
  let isDragging = false;
  let isDraggingNode = false;
  let draggedNode = null;
  let dragStartX = 0;
  let dragStartY = 0;
  let dragStartPanX = 0;
  let dragStartPanY = 0;
  let hasUnsavedChanges = false;
  let mouseDownNode = null;
  let mouseDownTime = 0;
  let dragDelayTimer = null;
  let animationScheduled = false;
  let didDrag = false; // Track if actual dragging occurred

  // Conditional Formatting State
  let conditionalFormats = []; // Array of format rules: {type, name, order, targets, nodeColor, outlineColor, outlineThickness, nodeSize, lineColor, lineThickness}
  let currentFormatRule = 'default'; // 'default' or index in conditionalFormats array

  // Chart Border State
  let chartBorderArea = null; // {x1, y1, x2, y2}
  let isDrawingChartBorder = false;
  let chartBorderStartPoint = null;
  let chartBorderPreviewEnd = null;
  let isExportMode = false; // Track if we're in export mode

  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { alpha: false });
  
  let zoomLevel = 1.0;
  let panX = 0;
  let panY = 0;

  const loadingOverlay = document.getElementById('loading-overlay');
  const loadingText = document.getElementById('loading-text');
  const searchInput = document.getElementById('search-input');
  const searchBtn = document.getElementById('search-btn');
  const clearBtn = document.getElementById('clear-btn');
  const suggestionsEl = d3.select('#suggestions');
  const nodeTitleEl = d3.select('#node-title');
  const nodeMetaEl = d3.select('#node-meta');
  const nodeLinkEl = d3.select('#node-links');
  const connectionsBox = document.getElementById('connections-box');
  const msgEl = d3.select('#msg');
  const zoomInBtn = document.getElementById('zoom-in');
  const zoomOutBtn = document.getElementById('zoom-out');
  const zoomResetBtn = document.getElementById('zoom-reset');
  const fileInput = document.getElementById('file-input');
  const fileInputAdd = document.getElementById('file-input-add');
  const statusMsg = document.getElementById('status-msg');
  const downloadBtn = document.getElementById('download-btn');
  const confirmDialog = document.getElementById('confirm-dialog');
  const confirmMessage = document.getElementById('confirm-message');
  const exportControls = document.getElementById('export-controls');
  const exportOptionsModal = document.getElementById('export-options-modal');
  
  // Inline rule editing elements
  const formatRuleSelector = document.getElementById('format-rule-selector');
  const ruleControls = document.getElementById('rule-controls');
  const ruleUpBtn = document.getElementById('rule-up-btn');
  const ruleDownBtn = document.getElementById('rule-down-btn');
  const ruleDeleteBtn = document.getElementById('rule-delete-btn');
  const ruleNameSection = document.getElementById('rule-name-section');
  const ruleNameInput = document.getElementById('rule-name-input');
  const ruleTargetsSection = document.getElementById('rule-targets-section');
  const ruleTargetsLabel = document.getElementById('rule-targets-label');
  const ruleTargetsSearch = document.getElementById('rule-targets-search');
  const ruleTargetsList = document.getElementById('rule-targets-list');
  const ruleSelectedTargets = document.getElementById('rule-selected-targets');
  
  // Tab and formatting elements
  const entitiesTab = document.getElementById('entities-tab');
  const formattingTab = document.getElementById('formatting-tab');
  const entityTableContainer = document.getElementById('entity-table-container');
  const formattingMenu = document.getElementById('formatting-menu');
  const fmtNodeColor = document.getElementById('fmt-node-color');
  const fmtNodeHoverColor = document.getElementById('fmt-node-hover-color');
  const fmtLineColor = document.getElementById('fmt-line-color');
  const fmtLineHoverColor = document.getElementById('fmt-line-hover-color');
  const fmtLineThickness = document.getElementById('fmt-line-thickness');
  const fmtLineHoverThickness = document.getElementById('fmt-line-hover-thickness');
  const fmtOutlineColor = document.getElementById('fmt-outline-color');
  const fmtOutlineHoverColor = document.getElementById('fmt-outline-hover-color');
  const fmtOutlineThickness = document.getElementById('fmt-outline-thickness');
  const fmtOutlineHoverThickness = document.getElementById('fmt-outline-hover-thickness');
  const fmtBgColor = document.getElementById('fmt-bg-color');
  const fmtSizeMode = document.getElementById('fmt-size-mode');
  const fmtCustomSize = document.getElementById('fmt-custom-size');
  const fmtMinSize = document.getElementById('fmt-min-size');
  const fmtMaxSize = document.getElementById('fmt-max-size');
  const fmtSizeScale = document.getElementById('fmt-size-scale');
  const scaleValueDisplay = document.getElementById('scale-value');
  const customSizeControl = document.getElementById('custom-size-control');
  const customSizeCheckboxControl = document.getElementById("custom-size-checkbox-control");
  const fmtCustomSizeEnabled = document.getElementById("fmt-custom-size-enabled");
  
  // Controls to hide for conditional rules
  const sizeModeControl = document.getElementById('size-mode-control');
  const minSizeControl = document.getElementById('min-size-control');
  const maxSizeControl = document.getElementById('max-size-control');
  const sizeScaleControl = document.getElementById('size-scale-control');
  const otherOptionsSection = document.getElementById('other-options-section');
  const otherOptionsDivider = document.getElementById('other-options-divider');
  const nodeHoverColorControl = document.getElementById('node-hover-color-control');
  const outlineHoverColorControl = document.getElementById('outline-hover-color-control');
  const outlineHoverThicknessControl = document.getElementById('outline-hover-thickness-control');
  const lineHoverColorControl = document.getElementById('line-hover-color-control');
  const lineHoverThicknessControl = document.getElementById('line-hover-thickness-control');

  /************************************************************************
   * CANVAS SETUP
   ************************************************************************/
  function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    const hiResScale = devicePixelRatio * 1.5;
    canvas.width  = Math.max(600, Math.floor(rect.width  * hiResScale));
    canvas.height = Math.max(400, Math.floor(rect.height * hiResScale));
    canvas.style.width = rect.width + 'px';
    canvas.style.height = rect.height + 'px';
    ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
  }
  
  window.addEventListener('resize', () => { 
    resizeCanvas(); 
    if (simulation && simulation.force) { 
      const c = simulation.force('center'); 
      if (c) {
        c.x((canvas.width/devicePixelRatio)/2);
        c.y((canvas.height/devicePixelRatio)/2);
      }
    } 
    render();
  });
  
  resizeCanvas();

  /************************************************************************
   * INITIALIZE FORMATTING CONTROLS
   ************************************************************************/
  function initializeFormattingControls() {
    // Set all UI controls to match default formattingSettings
    fmtNodeColor.value = formattingSettings.nodeColor;
    fmtNodeHoverColor.value = formattingSettings.nodeHoverColor;
    fmtLineColor.value = formattingSettings.lineColor;
    fmtLineHoverColor.value = formattingSettings.lineHoverColor;
    fmtLineThickness.value = formattingSettings.lineThickness;
    fmtLineHoverThickness.value = formattingSettings.lineHoverThickness;
    fmtOutlineColor.value = formattingSettings.outlineColor;
    fmtOutlineHoverColor.value = formattingSettings.outlineHoverColor;
    fmtOutlineThickness.value = formattingSettings.outlineThickness;
    fmtOutlineHoverThickness.value = formattingSettings.outlineHoverThickness;
    fmtBgColor.value = formattingSettings.backgroundColor;
    fmtSizeMode.value = formattingSettings.nodeSizeMode;
    fmtCustomSize.value = formattingSettings.customNodeSize;
    fmtMinSize.value = formattingSettings.minNodeSize;
    fmtMaxSize.value = formattingSettings.maxNodeSize;
    
    // Set size scale slider to 50 (middle position = 1x)
    fmtSizeScale.value = 50;
    scaleValueDisplay.textContent = '1.0x';
    
    // Hide custom size control if not in custom mode
    if (formattingSettings.nodeSizeMode !== 'custom') {
      customSizeControl.style.display = 'none';
    }
  }
  
  // Initialize controls on page load
  initializeFormattingControls();

  /************************************************************************
   * AUTO-LOAD CSVs FROM FOLDER
   ************************************************************************/
  async function autoLoadCSVs() {
    try {
      // Try to fetch the CSVs from the same folder as the HTML file
      const entitiesPromise = fetch('Entities.csv');
      const connectionsPromise = fetch('Connections.csv');
      const formattingPromise = fetch('Formatting.csv');
      
      const [entitiesResponse, connectionsResponse, formattingResponse] = await Promise.all([
        entitiesPromise.catch(() => null),
        connectionsPromise.catch(() => null),
        formattingPromise.catch(() => null)
      ]);
      
      // Check if at least Entities and Connections exist
      if (!entitiesResponse || !entitiesResponse.ok || !connectionsResponse || !connectionsResponse.ok) {
        console.log('Default CSVs not found in folder. Please upload files manually.');
        return;
      }
      
      loadingOverlay.style.display = 'flex';
      loadingText.textContent = 'Loading default CSVs...';
      
      // Parse the CSV text
      const entitiesText = await entitiesResponse.text();
      const connectionsText = await connectionsResponse.text();
      const formattingText = formattingResponse && formattingResponse.ok ? await formattingResponse.text() : null;
      
      // Parse with PapaParse
      const entitiesData = await new Promise((resolve, reject) => {
        Papa.parse(entitiesText, {
          header: true,
          skipEmptyLines: true,
          complete: (results) => resolve(results.data),
          error: (error) => reject(error)
        });
      });
      
      const connectionsData = await new Promise((resolve, reject) => {
        Papa.parse(connectionsText, {
          header: true,
          skipEmptyLines: true,
          complete: (results) => resolve(results.data),
          error: (error) => reject(error)
        });
      });
      
      let formattingData = null;
      if (formattingText) {
        formattingData = await new Promise((resolve, reject) => {
          Papa.parse(formattingText, {
            header: true,
            skipEmptyLines: true,
            complete: (results) => resolve(results.data),
            error: (error) => reject(error)
          });
        });
        
        if (formattingData && formattingData.length > 0) {
          loadFormattingData(formattingData);
        }
      }
      
      // Load the data
      loadSession(entitiesData, connectionsData);
      showStatus(`Loaded ${nodes.length} entities and ${links.length} connections`, 'success');
      hasUnsavedChanges = false;
      updateDownloadButton();
      
    } catch (err) {
      console.log('Could not auto-load CSVs:', err.message);
      // Silently fail - user can upload manually
    }
  }
  
  // Attempt to auto-load CSVs on page load
  autoLoadCSVs();

  /************************************************************************
   * TAB SWITCHING
   ************************************************************************/
  entitiesTab.addEventListener('click', () => {
    entitiesTab.classList.add('active');
    formattingTab.classList.remove('active');
    entityTableContainer.style.display = 'flex';
    formattingMenu.style.display = 'none';
  });
  
  formattingTab.addEventListener('click', () => {
    formattingTab.classList.add('active');
    entitiesTab.classList.remove('active');
    entityTableContainer.style.display = 'none';
    formattingMenu.style.display = 'flex';
  });

  /************************************************************************
   * FORMATTING CONTROLS
   ************************************************************************/
  fmtNodeColor.addEventListener('input', (e) => {
    if (currentEditingRuleIndex !== null) {
      conditionalFormats[currentEditingRuleIndex].nodeColor = e.target.value;
      invalidateFormatCache();
    } else {
      formattingSettings.nodeColor = e.target.value;
    }
    render();
  });

  fmtNodeHoverColor.addEventListener('input', (e) => {
    formattingSettings.nodeHoverColor = e.target.value;
    render();
  });

  fmtLineColor.addEventListener('input', (e) => {
    if (currentEditingRuleIndex !== null) {
      conditionalFormats[currentEditingRuleIndex].lineColor = e.target.value;
      invalidateFormatCache();
    } else {
      formattingSettings.lineColor = e.target.value;
    }
    render();
  });

  fmtLineHoverColor.addEventListener('input', (e) => {
    formattingSettings.lineHoverColor = e.target.value;
    render();
  });
  
  fmtLineThickness.addEventListener('input', (e) => {
    if (currentEditingRuleIndex !== null) {
      conditionalFormats[currentEditingRuleIndex].lineThickness = parseFloat(e.target.value);
      invalidateFormatCache();
    } else {
      formattingSettings.lineThickness = parseFloat(e.target.value);
    }
    render();
  });

  fmtLineHoverThickness.addEventListener('input', (e) => {
    formattingSettings.lineHoverThickness = parseFloat(e.target.value);
    render();
  });
  
  fmtOutlineColor.addEventListener('input', (e) => {
    if (currentEditingRuleIndex !== null) {
      conditionalFormats[currentEditingRuleIndex].outlineColor = e.target.value;
      invalidateFormatCache();
    } else if (!isCreatingNewRule) {
      // Only update default if not creating a new rule
      formattingSettings.outlineColor = e.target.value;
    }
    render();
  });

  fmtOutlineHoverColor.addEventListener('input', (e) => {
    formattingSettings.outlineHoverColor = e.target.value;
    render();
  });
  
  fmtOutlineThickness.addEventListener('input', (e) => {
    if (currentEditingRuleIndex !== null) {
      conditionalFormats[currentEditingRuleIndex].outlineThickness = parseFloat(e.target.value);
      invalidateFormatCache();
    } else {
      formattingSettings.outlineThickness = parseFloat(e.target.value);
    }
    render();
  });

  fmtOutlineHoverThickness.addEventListener('input', (e) => {
    formattingSettings.outlineHoverThickness = parseFloat(e.target.value);
    render();
  });
  
  fmtBgColor.addEventListener('input', (e) => {
    formattingSettings.backgroundColor = e.target.value;
    document.documentElement.style.setProperty('--bg-white', e.target.value);
    render();
  });

  fmtSizeMode.addEventListener('change', (e) => {
    formattingSettings.nodeSizeMode = e.target.value;
    if (e.target.value === 'custom') {
      customSizeControl.style.display = 'flex';
    } else {
      customSizeControl.style.display = 'none';
    }
    updateNodeSizes();
    schedulePhysicsRestart();
    render();
  });

  fmtCustomSize.addEventListener('input', (e) => {
    if (currentEditingRuleIndex !== null) {
      conditionalFormats[currentEditingRuleIndex].nodeSize = parseFloat(e.target.value);
      invalidateFormatCache();
      schedulePhysicsRestart();
    } else {
      formattingSettings.customNodeSize = parseFloat(e.target.value);
      if (formattingSettings.nodeSizeMode === 'custom') {
        updateNodeSizes();
        schedulePhysicsRestart();
      }
    }
    render();
  });

  fmtMinSize.addEventListener('input', (e) => {
    formattingSettings.minNodeSize = parseFloat(e.target.value);
    updateNodeSizes();
    schedulePhysicsRestart();
    render();
  });

  fmtMaxSize.addEventListener('input', (e) => {
    formattingSettings.maxNodeSize = parseFloat(e.target.value);
    updateNodeSizes();
    schedulePhysicsRestart();
    render();
  });

  fmtSizeScale.addEventListener('input', (e) => {
    const sliderValue = parseFloat(e.target.value);
    let scale;
    
    // Map slider value (0-100) to scale (0.1x-10x) with 50=1x
    if (sliderValue <= 50) {
      // 0-50 maps to 0.1x-1x (linear)
      scale = 0.1 + (sliderValue / 50) * 0.9;
    } else {
      // 50-100 maps to 1x-10x (linear)
      scale = 1.0 + ((sliderValue - 50) / 50) * 9.0;
    }
    
    formattingSettings.sizeScale = scale;
    scaleValueDisplay.textContent = scale.toFixed(1) + 'x';
    applyNodeSizeScale();
    schedulePhysicsRestart();
    render();
  });

  /************************************************************************
   * CONDITIONAL FORMATTING
   ************************************************************************/
  let currentEditingRuleIndex = null;
  let selectedTargetsSet = new Set();
  let currentRuleType = null;
  let isCreatingNewRule = false;

  // Handle format rule selector dropdown
  formatRuleSelector.addEventListener('change', (e) => {
    const value = e.target.value;
    
    if (value === 'create-entity' || value === 'create-category') {
      // Start creating a new rule
      isCreatingNewRule = true;
      currentRuleType = value === 'create-entity' ? 'entity' : 'category';
      currentEditingRuleIndex = null;
      selectedTargetsSet.clear();
      
      // Show rule creation interface
      showRuleEditInterface(currentRuleType, null);
      
    } else {
      // Loading existing rule or default
      isCreatingNewRule = false;
      currentFormatRule = value;
      loadFormatRule(value);
    }
  });

  function showRuleEditInterface(type, ruleIndex) {
    // Show name and targets sections
    ruleNameSection.style.display = 'block';
    ruleTargetsSection.style.display = 'block';
    
    // Hide default-only controls for conditional rules
    sizeModeControl.style.display = 'none';
    minSizeControl.style.display = 'none';
    maxSizeControl.style.display = 'none';
    sizeScaleControl.style.display = 'none';
    otherOptionsSection.style.display = 'none';
    otherOptionsDivider.style.display = 'none';
    
    // Hide hover controls (only for default formatting)
    nodeHoverColorControl.style.display = 'none';
    outlineHoverColorControl.style.display = 'none';
    outlineHoverThicknessControl.style.display = 'none';
    lineHoverColorControl.style.display = 'none';
    lineHoverThicknessControl.style.display = 'none';
    
    // Show custom size checkbox for conditional rules
    customSizeCheckboxControl.style.display = 'flex';
    customSizeControl.style.display = 'none'; // Initially hide the size input
    
    // Set targets label
    ruleTargetsLabel.textContent = type === 'entity' ? 'ENTITIES' : 'CATEGORIES';
    
    // Load rule data if editing
    if (ruleIndex !== null) {
      const rule = conditionalFormats[ruleIndex];
      ruleNameInput.value = rule.name;
      selectedTargetsSet = new Set(rule.targets);
      
      // Show rule controls
      ruleControls.style.display = 'flex';
      ruleUpBtn.disabled = ruleIndex === 0;
      ruleDownBtn.disabled = ruleIndex === conditionalFormats.length - 1;
      
      // Enable all formatting controls since rule exists
      enableFormattingControls();
      
      // Set custom size checkbox and input based on rule
      if (rule.nodeSize) {
        fmtCustomSizeEnabled.checked = true;
        customSizeControl.style.display = 'flex';
        fmtCustomSize.value = rule.nodeSize;
      } else {
        fmtCustomSizeEnabled.checked = false;
        customSizeControl.style.display = 'none';
      }
    } else {
      // New rule - disable controls until name is entered
      ruleNameInput.value = '';
      selectedTargetsSet.clear();
      ruleControls.style.display = 'none';
      fmtCustomSizeEnabled.checked = false;
      
      // Disable all formatting controls until rule name is entered
      disableFormattingControls();
    }
    
    updateTargetsList();
    updateSelectedTargets();
    
    // Focus on name input
    setTimeout(() => ruleNameInput.focus(), 100);
  }

  function hideRuleEditInterface() {
    ruleNameSection.style.display = 'none';
    ruleTargetsSection.style.display = 'none';
    ruleControls.style.display = 'none';
    customSizeCheckboxControl.style.display = 'none';
    customSizeControl.style.display = 'none';
    
    // Show hover controls (for default formatting)
    nodeHoverColorControl.style.display = 'flex';
    outlineHoverColorControl.style.display = 'flex';
    outlineHoverThicknessControl.style.display = 'flex';
    lineHoverColorControl.style.display = 'flex';
    lineHoverThicknessControl.style.display = 'flex';
  }

  function disableFormattingControls() {
    // Disable all formatting controls and make them look faded
    fmtNodeColor.disabled = true;
    fmtOutlineColor.disabled = true;
    fmtOutlineThickness.disabled = true;
    fmtLineColor.disabled = true;
    fmtLineThickness.disabled = true;
    fmtCustomSizeEnabled.disabled = true;
    fmtCustomSize.disabled = true;
    
    // Add faded appearance
    fmtNodeColor.style.opacity = '0.5';
    fmtOutlineColor.style.opacity = '0.5';
    fmtOutlineThickness.style.opacity = '0.5';
    fmtLineColor.style.opacity = '0.5';
    fmtLineThickness.style.opacity = '0.5';
    fmtCustomSizeEnabled.style.opacity = '0.5';
    fmtCustomSize.style.opacity = '0.5';
  }

  function enableFormattingControls() {
    // Enable all formatting controls
    fmtNodeColor.disabled = false;
    fmtOutlineColor.disabled = false;
    fmtOutlineThickness.disabled = false;
    fmtLineColor.disabled = false;
    fmtLineThickness.disabled = false;
    fmtCustomSizeEnabled.disabled = false;
    fmtCustomSize.disabled = false;
    
    // Remove faded appearance
    fmtNodeColor.style.opacity = '1';
    fmtOutlineColor.style.opacity = '1';
    fmtOutlineThickness.style.opacity = '1';
    fmtLineColor.style.opacity = '1';
    fmtLineThickness.style.opacity = '1';
    fmtCustomSizeEnabled.style.opacity = '1';
    fmtCustomSize.style.opacity = '1';
  }

  // Auto-save when rule name changes
  ruleNameInput.addEventListener('input', () => {
    const ruleName = ruleNameInput.value.trim();
    
    // Enable formatting controls once user enters a name
    if (ruleName) {
      enableFormattingControls();
    } else {
      disableFormattingControls();
      return;
    }
    
    if (isCreatingNewRule && ruleName) {
      // Create the rule immediately with current control values
      const newRule = {
        type: currentRuleType,
        name: ruleName,
        order: conditionalFormats.length,
        targets: Array.from(selectedTargetsSet),
        nodeColor: fmtNodeColor.value,
        outlineColor: fmtOutlineColor.value,
        outlineThickness: parseFloat(fmtOutlineThickness.value),
        nodeSize: (fmtCustomSizeEnabled.checked && fmtCustomSize.value) ? parseFloat(fmtCustomSize.value) : null,
        lineColor: fmtLineColor.value,
        lineThickness: parseFloat(fmtLineThickness.value)
      };
      
      conditionalFormats.push(newRule);
      currentEditingRuleIndex = conditionalFormats.length - 1;
      isCreatingNewRule = false;
      
      updateFormatRuleSelector();
      currentFormatRule = currentEditingRuleIndex.toString();
      formatRuleSelector.value = currentFormatRule;
      
      // Show rule controls now
      ruleControls.style.display = 'flex';
      ruleUpBtn.disabled = currentEditingRuleIndex === 0;
      ruleDownBtn.disabled = currentEditingRuleIndex === conditionalFormats.length - 1;
      
      invalidateFormatCache();
      render();
    } else if (currentEditingRuleIndex !== null) {
      // Update existing rule name
      conditionalFormats[currentEditingRuleIndex].name = ruleName;
      updateFormatRuleSelector();
      formatRuleSelector.value = currentEditingRuleIndex.toString();
    }
  });

  function updateTargetsList() {
    const searchTerm = ruleTargetsSearch.value.toLowerCase();
    ruleTargetsList.innerHTML = '';
    
    // Get unique entities or categories
    const items = new Set();
    nodes.forEach(node => {
      if (currentRuleType === 'entity') {
        items.add(node.name);
      } else {
        const category = (node.raw && (node.raw['Category'] || '')) || '';
        if (category) items.add(category);
      }
    });
    
    const sorted = Array.from(items).sort((a, b) => a.localeCompare(b, undefined, {sensitivity: 'base'}));
    const filtered = searchTerm ? sorted.filter(item => item.toLowerCase().includes(searchTerm)) : sorted;
    
    filtered.forEach(item => {
      const div = document.createElement('div');
      div.style.cssText = 'padding: 6px; cursor: pointer; display: flex; align-items: center; gap: 8px;';
      
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.checked = selectedTargetsSet.has(item);
      checkbox.addEventListener('change', () => {
        if (checkbox.checked) {
          selectedTargetsSet.add(item);
        } else {
          selectedTargetsSet.delete(item);
        }
        updateSelectedTargets();
        saveTargetsToRule();
      });
      
      const label = document.createElement('span');
      label.textContent = item;
      label.style.cssText = 'flex: 1; font-family: var(--font-family);';
      label.addEventListener('click', () => {
        checkbox.checked = !checkbox.checked;
        checkbox.dispatchEvent(new Event('change'));
      });
      
      div.appendChild(checkbox);
      div.appendChild(label);
      div.addEventListener('mouseenter', () => {
        div.style.background = 'var(--light-yellow)';
      });
      div.addEventListener('mouseleave', () => {
        div.style.background = 'transparent';
      });
      
      ruleTargetsList.appendChild(div);
    });
    
    if (filtered.length === 0) {
      ruleTargetsList.innerHTML = '<div style="padding: 12px; text-align: center; color: var(--shadow-grey); font-family: var(--font-family);">No items found</div>';
    }
  }

  function updateSelectedTargets() {
    ruleSelectedTargets.innerHTML = '';
    
    selectedTargetsSet.forEach(target => {
      const tag = document.createElement('div');
      tag.style.cssText = 'display: inline-flex; align-items: center; gap: 6px; background: var(--shadow-grey); color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; font-family: var(--font-family);';
      
      const text = document.createElement('span');
      text.textContent = target;
      
      const remove = document.createElement('span');
      remove.textContent = '×';
      remove.style.cssText = 'cursor: pointer; font-size: 16px; font-weight: bold;';
      remove.addEventListener('click', () => {
        selectedTargetsSet.delete(target);
        updateTargetsList();
        updateSelectedTargets();
        saveTargetsToRule();
      });
      
      tag.appendChild(text);
      tag.appendChild(remove);
      ruleSelectedTargets.appendChild(tag);
    });
  }

  function saveTargetsToRule() {
    if (currentEditingRuleIndex !== null) {
      conditionalFormats[currentEditingRuleIndex].targets = Array.from(selectedTargetsSet);
      invalidateFormatCache();
      render();
    }
  }

  ruleTargetsSearch.addEventListener('input', updateTargetsList);

  // Custom size checkbox event listener
  fmtCustomSizeEnabled.addEventListener('change', () => {
    if (fmtCustomSizeEnabled.checked) {
      customSizeControl.style.display = 'flex';
      if (currentEditingRuleIndex !== null) {
        conditionalFormats[currentEditingRuleIndex].nodeSize = parseFloat(fmtCustomSize.value) || 20;
        invalidateFormatCache();
        render();
      }
    } else {
      customSizeControl.style.display = 'none';
      if (currentEditingRuleIndex !== null) {
        conditionalFormats[currentEditingRuleIndex].nodeSize = null;
        invalidateFormatCache();
        render();
      }
    }
  });

  function loadFormatRule(ruleIdentifier) {
    if (ruleIdentifier === 'default') {
      // Hide all rule editing UI
      hideRuleEditInterface();
      
      // Show default-only controls
      sizeModeControl.style.display = 'flex';
      minSizeControl.style.display = 'flex';
      maxSizeControl.style.display = 'flex';
      sizeScaleControl.style.display = 'flex';
      otherOptionsSection.style.display = 'block';
      otherOptionsDivider.style.display = 'block';
      nodeHoverColorControl.style.display = 'flex';
      outlineHoverColorControl.style.display = 'flex';
      outlineHoverThicknessControl.style.display = 'flex';
      lineHoverColorControl.style.display = 'flex';
      lineHoverThicknessControl.style.display = 'flex';
      
      // Load default formatting settings into controls
      fmtNodeColor.value = formattingSettings.nodeColor;
      fmtNodeHoverColor.value = formattingSettings.nodeHoverColor;
      fmtOutlineColor.value = formattingSettings.outlineColor;
      fmtOutlineHoverColor.value = formattingSettings.outlineHoverColor;
      fmtOutlineThickness.value = formattingSettings.outlineThickness;
      fmtOutlineHoverThickness.value = formattingSettings.outlineHoverThickness;
      fmtLineColor.value = formattingSettings.lineColor;
      fmtLineHoverColor.value = formattingSettings.lineHoverColor;
      fmtLineThickness.value = formattingSettings.lineThickness;
      fmtLineHoverThickness.value = formattingSettings.lineHoverThickness;
      
      currentEditingRuleIndex = null;
      currentRuleType = null;
    } else {
      const ruleIndex = parseInt(ruleIdentifier);
      const rule = conditionalFormats[ruleIndex];
      
      if (rule) {
        currentEditingRuleIndex = ruleIndex;
        currentRuleType = rule.type;
        isCreatingNewRule = false;
        
        // Hide default-only controls
        sizeModeControl.style.display = 'none';
        minSizeControl.style.display = 'none';
        maxSizeControl.style.display = 'none';
        sizeScaleControl.style.display = 'none';
        otherOptionsSection.style.display = 'none';
        otherOptionsDivider.style.display = 'none';
        nodeHoverColorControl.style.display = 'none';
        outlineHoverColorControl.style.display = 'none';
        outlineHoverThicknessControl.style.display = 'none';
        lineHoverColorControl.style.display = 'none';
        lineHoverThicknessControl.style.display = 'none';
        
        // Show rule edit interface
        showRuleEditInterface(rule.type, ruleIndex);
        
        // Load rule values into formatting controls
        fmtNodeColor.value = rule.nodeColor || formattingSettings.nodeColor;
        fmtOutlineColor.value = rule.outlineColor || formattingSettings.outlineColor;
        fmtOutlineThickness.value = rule.outlineThickness || formattingSettings.outlineThickness;
        
        // Load custom size if available
        if (rule.nodeSize) {
          fmtCustomSizeEnabled.checked = true;
          fmtCustomSize.value = rule.nodeSize;
          customSizeCheckboxControl.style.display = 'flex';
          customSizeControl.style.display = 'flex';
        } else {
          fmtCustomSizeEnabled.checked = false;
          fmtCustomSize.value = '';
          customSizeCheckboxControl.style.display = 'flex';
          customSizeControl.style.display = 'none';
        }
        
        fmtLineColor.value = rule.lineColor || formattingSettings.lineColor;
        fmtLineThickness.value = rule.lineThickness || formattingSettings.lineThickness;
      }
    }
  }

  function updateFormatRuleSelector() {
    // Save current selection
    const currentSelection = formatRuleSelector.value;
    
    // Clear existing options except default and create buttons
    formatRuleSelector.innerHTML = '<option value="default">DEFAULT FORMAT</option>';
    
    // Add existing rules
    conditionalFormats.forEach((rule, index) => {
      const option = document.createElement('option');
      option.value = index;
      option.textContent = `${rule.type === 'entity' ? 'Entity' : 'Category'}: ${rule.name}`;
      formatRuleSelector.appendChild(option);
    });
    
    // Add separator
    const separator = document.createElement('optgroup');
    separator.label = '───────────────';
    separator.disabled = true;
    formatRuleSelector.appendChild(separator);
    
    // Add create buttons
    const createEntity = document.createElement('option');
    createEntity.value = 'create-entity';
    createEntity.textContent = '+ Create a new Entity rule';
    formatRuleSelector.appendChild(createEntity);
    
    const createCategory = document.createElement('option');
    createCategory.value = 'create-category';
    createCategory.textContent = '+ Create a new Category rule';
    formatRuleSelector.appendChild(createCategory);
    
    // Restore selection if still valid
    if (currentSelection !== 'create-entity' && currentSelection !== 'create-category') {
      formatRuleSelector.value = currentSelection;
    }
  }

  function invalidateFormatCache() {
    // Clear cached formatting on nodes
    nodes.forEach(node => {
      delete node._cachedFormat;
    });
    links.forEach(link => {
      delete link._cachedFormat;
    });
  }

  function getNodeFormat(node) {
    if (node._cachedFormat) return node._cachedFormat;
    
    // Check conditional formats in order
    for (const rule of conditionalFormats) {
      if (rule.type === 'entity' && rule.targets.includes(node.name)) {
        node._cachedFormat = rule;
        return rule;
      }
      if (rule.type === 'category') {
        const category = (node.raw && (node.raw['Category'] || '')) || '';
        if (rule.targets.includes(category)) {
          node._cachedFormat = rule;
          return rule;
        }
      }
    }
    
    node._cachedFormat = null;
    return null;
  }

  function getLinkFormat(link) {
    if (link._cachedFormat) return link._cachedFormat;
    
    // Check if either endpoint has conditional formatting
    const sourceFormat = getNodeFormat(link.source);
    const targetFormat = getNodeFormat(link.target);
    
    // Use the higher precedence format (earlier in array)
    if (sourceFormat && targetFormat) {
      const sourceIndex = conditionalFormats.indexOf(sourceFormat);
      const targetIndex = conditionalFormats.indexOf(targetFormat);
      link._cachedFormat = sourceIndex <= targetIndex ? sourceFormat : targetFormat;
    } else if (sourceFormat) {
      link._cachedFormat = sourceFormat;
    } else if (targetFormat) {
      link._cachedFormat = targetFormat;
    } else {
      link._cachedFormat = null;
    }
    
    return link._cachedFormat;
  }

  // Rule management button handlers
  ruleUpBtn.addEventListener('click', () => {
    if (currentEditingRuleIndex !== null && currentEditingRuleIndex > 0) {
      // Swap with previous rule
      [conditionalFormats[currentEditingRuleIndex], conditionalFormats[currentEditingRuleIndex - 1]] = 
      [conditionalFormats[currentEditingRuleIndex - 1], conditionalFormats[currentEditingRuleIndex]];
      
      // Update orders
      conditionalFormats.forEach((rule, idx) => rule.order = idx);
      
      // Update UI
      currentEditingRuleIndex = currentEditingRuleIndex - 1;
      updateFormatRuleSelector();
      currentFormatRule = currentEditingRuleIndex.toString();
      formatRuleSelector.value = currentFormatRule;
      loadFormatRule(currentFormatRule);
      invalidateFormatCache();
      render();
    }
  });

  ruleDownBtn.addEventListener('click', () => {
    if (currentEditingRuleIndex !== null && currentEditingRuleIndex < conditionalFormats.length - 1) {
      // Swap with next rule
      [conditionalFormats[currentEditingRuleIndex], conditionalFormats[currentEditingRuleIndex + 1]] = 
      [conditionalFormats[currentEditingRuleIndex + 1], conditionalFormats[currentEditingRuleIndex]];
      
      // Update orders
      conditionalFormats.forEach((rule, idx) => rule.order = idx);
      
      // Update UI
      currentEditingRuleIndex = currentEditingRuleIndex + 1;
      updateFormatRuleSelector();
      currentFormatRule = currentEditingRuleIndex.toString();
      formatRuleSelector.value = currentFormatRule;
      loadFormatRule(currentFormatRule);
      invalidateFormatCache();
      render();
    }
  });

  ruleDeleteBtn.addEventListener('click', () => {
    if (currentEditingRuleIndex !== null) {
      const rule = conditionalFormats[currentEditingRuleIndex];
      
      if (rule) {
        // Show confirmation dialog
        showConfirmDialog(`Delete rule "${rule.name}"?`, () => {
          // Remove the rule
          conditionalFormats.splice(currentEditingRuleIndex, 1);
          
          // Update orders
          conditionalFormats.forEach((r, idx) => r.order = idx);
          
          // Switch to default
          currentFormatRule = 'default';
          currentEditingRuleIndex = null;
          formatRuleSelector.value = 'default';
          
          // Update UI
          updateFormatRuleSelector();
          loadFormatRule('default');
          invalidateFormatCache();
          render();
        });
      }
    }
  });

  /************************************************************************
   * FILE UPLOAD - REPLACE
   ************************************************************************/
  fileInput.addEventListener('change', async (e) => {
    await handleFileUpload(e.target.files, false);
    fileInput.value = '';
  });

  /************************************************************************
   * FILE UPLOAD - ADD
   ************************************************************************/
  fileInputAdd.addEventListener('change', async (e) => {
    await handleFileUpload(e.target.files, true);
    fileInputAdd.value = '';
  });

  async function handleFileUpload(files, isAppend) {
    const filesArray = Array.from(files);
    
    if (filesArray.length === 0) return;
    
    if (filesArray.length < 2 || filesArray.length > 3) {
      showStatus('Please select Entities.csv, Connections.csv, and optionally Formatting.csv', 'error');
      return;
    }
    
    const entitiesFile = filesArray.find(f => f.name.toLowerCase().includes('entities'));
    const connectionsFile = filesArray.find(f => f.name.toLowerCase().includes('connections') || f.name.toLowerCase().includes('links'));
    const formattingFile = filesArray.find(f => f.name.toLowerCase().includes('formatting'));
    
    if (!entitiesFile || !connectionsFile) {
      showStatus('Files must include "Entities" and "Connections" (or "Links") in their names', 'error');
      return;
    }
    
    loadingOverlay.style.display = 'flex';
    loadingText.textContent = isAppend ? 'Adding CSVs...' : 'Loading CSVs...';
    
    try {
      const promises = [
        parseCSVFile(entitiesFile),
        parseCSVFile(connectionsFile)
      ];
      if (formattingFile) {
        promises.push(parseCSVFile(formattingFile));
      }
      
      const results = await Promise.all(promises);
      const entitiesData = results[0];
      const connectionsData = results[1];
      const formattingData = formattingFile ? results[2] : null;
      
      if (formattingData) {
        loadFormattingData(formattingData);
      }
      
      if (isAppend) {
        appendSession(entitiesData, connectionsData);
        showStatus(`Added ${entitiesData.length} entities`, 'success');
      } else {
        loadSession(entitiesData, connectionsData);
        showStatus(`Loaded ${nodes.length} entities, ${links.length} connections`, 'success');
      }
      
      hasUnsavedChanges = false;
      updateDownloadButton();
    } catch (err) {
      console.error('CSV parse error', err);
      showStatus('Failed to parse CSV files', 'error');
      loadingOverlay.style.display = 'none';
    }
  }

  function parseCSVFile(file) {
    return new Promise((resolve, reject) => {
      Papa.parse(file, {
        header: true,
        skipEmptyLines: true,
        complete: (results) => resolve(results.data),
        error: (error) => reject(error)
      });
    });
  }

  function loadFormattingData(data) {
    if (!data || data.length === 0) return;
    
    // Clear existing conditional formats
    conditionalFormats = [];
    
    // Process each row
    data.forEach(row => {
      if (row.RuleType === 'Default' || !row.RuleType) {
        // Load default formatting settings
        if (row.NodeColor) {
          formattingSettings.nodeColor = row.NodeColor;
          fmtNodeColor.value = row.NodeColor;
        }
        if (row.NodeHoverColor) {
          formattingSettings.nodeHoverColor = row.NodeHoverColor;
          fmtNodeHoverColor.value = row.NodeHoverColor;
        }
        if (row.LineColor) {
          formattingSettings.lineColor = row.LineColor;
          fmtLineColor.value = row.LineColor;
        }
        if (row.LineHoverColor) {
          formattingSettings.lineHoverColor = row.LineHoverColor;
          fmtLineHoverColor.value = row.LineHoverColor;
        }
        if (row.LineThickness) {
          formattingSettings.lineThickness = parseFloat(row.LineThickness);
          fmtLineThickness.value = row.LineThickness;
        }
        if (row.LineHoverThickness) {
          formattingSettings.lineHoverThickness = parseFloat(row.LineHoverThickness);
          fmtLineHoverThickness.value = row.LineHoverThickness;
        }
        if (row.OutlineColor) {
          formattingSettings.outlineColor = row.OutlineColor;
          fmtOutlineColor.value = row.OutlineColor;
        }
        if (row.OutlineHoverColor) {
          formattingSettings.outlineHoverColor = row.OutlineHoverColor;
          fmtOutlineHoverColor.value = row.OutlineHoverColor;
        }
        if (row.OutlineThickness) {
          formattingSettings.outlineThickness = parseFloat(row.OutlineThickness);
          fmtOutlineThickness.value = row.OutlineThickness;
        }
        if (row.OutlineHoverThickness) {
          formattingSettings.outlineHoverThickness = parseFloat(row.OutlineHoverThickness);
          fmtOutlineHoverThickness.value = row.OutlineHoverThickness;
        }
        if (row.BackgroundColor) {
          formattingSettings.backgroundColor = row.BackgroundColor;
          fmtBgColor.value = row.BackgroundColor;
          document.documentElement.style.setProperty('--bg-white', row.BackgroundColor);
        }
        // Load chart border area
        if (row.ChartBorderX1 && row.ChartBorderY1 && row.ChartBorderX2 && row.ChartBorderY2) {
          chartBorderArea = {
            x1: parseFloat(row.ChartBorderX1),
            y1: parseFloat(row.ChartBorderY1),
            x2: parseFloat(row.ChartBorderX2),
            y2: parseFloat(row.ChartBorderY2)
          };
        }
      } else if (row.RuleType === 'Entity' || row.RuleType === 'Category') {
        // Load conditional format rule
        const targets = row.Targets ? row.Targets.split('|').map(t => t.trim()).filter(t => t) : [];
        
        conditionalFormats.push({
          type: row.RuleType.toLowerCase(),
          name: row.RuleName || 'Unnamed Rule',
          order: parseInt(row.Order) || conditionalFormats.length,
          targets: targets,
          nodeColor: row.NodeColor || null,
          outlineColor: row.OutlineColor || null,
          outlineThickness: row.OutlineThickness ? parseFloat(row.OutlineThickness) : null,
          nodeSize: row.NodeSize ? parseFloat(row.NodeSize) : null,
          lineColor: row.LineColor || null,
          lineThickness: row.LineThickness ? parseFloat(row.LineThickness) : null
        });
      }
    });
    
    // Sort conditional formats by order
    conditionalFormats.sort((a, b) => a.order - b.order);
    
    // Update the dropdown
    updateFormatRuleSelector();
    invalidateFormatCache();
  }

  function showStatus(msg, type = 'success') {
    statusMsg.textContent = msg;
    statusMsg.className = 'status-msg' + (type === 'error' ? ' error' : '');
    setTimeout(() => {
      statusMsg.textContent = '';
    }, 5000);
  }

  /************************************************************************
   * CONFIRM DIALOG
   ************************************************************************/
  let confirmCallback = null;

  function showConfirmDialog(message, onConfirm) {
    confirmMessage.textContent = message;
    confirmCallback = onConfirm;
    confirmDialog.style.display = 'flex';
  }

  function closeConfirmDialog() {
    confirmDialog.style.display = 'none';
    confirmCallback = null;
  }

  document.getElementById('confirm-yes').addEventListener('click', () => {
    if (confirmCallback) {
      confirmCallback();
    }
    closeConfirmDialog();
  });

  document.getElementById('confirm-no').addEventListener('click', closeConfirmDialog);

  /************************************************************************
   * LOAD SESSION (REPLACE)
   ************************************************************************/
  function loadSession(entitiesData, connectionsData) {
    // Clean headers
    entitiesData.forEach(r => { 
      Object.keys(r).forEach(k => { 
        if (k !== k.trim()) { 
          r[k.trim()] = r[k]; 
          delete r[k]; 
        } 
      }); 
    });
    
    connectionsData.forEach(r => { 
      Object.keys(r).forEach(k => { 
        if (k !== k.trim()) { 
          r[k.trim()] = r[k]; 
          delete r[k]; 
        } 
      }); 
    });

    // Create nodes
    nodes = entitiesData.map((d, i) => createNodeFromData(d, i));
    nodeById = new Map(nodes.map(n => [n.id, n]));

    // Create links
    processLinksData(connectionsData);

    // Build adjacency
    buildAdjacency();

    nameIndex = nodes.map(n => n.name);

    // Calculate node sizes
    updateNodeSizes();

    // Load images
    loadAllImages();

    // Update entity table
    updateEntityTable();

    // Start physics
    updatePhysics();

    loadingOverlay.style.display = 'none';
  }

  /************************************************************************
   * APPEND SESSION (ADD)
   ************************************************************************/
  function appendSession(entitiesData, connectionsData) {
    // Clean headers
    entitiesData.forEach(r => { 
      Object.keys(r).forEach(k => { 
        if (k !== k.trim()) { 
          r[k.trim()] = r[k]; 
          delete r[k]; 
        } 
      }); 
    });
    
    connectionsData.forEach(r => { 
      Object.keys(r).forEach(k => { 
        if (k !== k.trim()) { 
          r[k.trim()] = r[k]; 
          delete r[k]; 
        } 
      }); 
    });

    // Add or update nodes
    entitiesData.forEach((d, i) => {
      const newNode = createNodeFromData(d, i);
      const existing = nodeById.get(newNode.id);
      
      if (existing) {
        // Replace existing node with new data
        const index = nodes.indexOf(existing);
        nodes[index] = newNode;
        nodeById.set(newNode.id, newNode);
      } else {
        // Add new node
        nodes.push(newNode);
        nodeById.set(newNode.id, newNode);
      }
    });

    // Process links
    processLinksData(connectionsData);

    // Rebuild adjacency
    buildAdjacency();

    nameIndex = nodes.map(n => n.name);

    // Recalculate node sizes
    updateNodeSizes();

    // Load new images
    loadAllImages();

    // Update entity table
    updateEntityTable();

    // Restart physics
    updatePhysics();

    loadingOverlay.style.display = 'none';
  }

  function createNodeFromData(d, i) {
    const id = d['Entity Name'] ? String(d['Entity Name']).trim() : `__P_${i}`;
    
    // Parse Show/Fixed/X/Y from CSV
    const show = d['Show'] === undefined ? true : (d['Show'] === 'true' || d['Show'] === '1' || d['Show'] === true);
    const isFixed = d['Fixed'] === 'true' || d['Fixed'] === '1' || d['Fixed'] === true;
    const savedX = parseFloat(d['X']);
    const savedY = parseFloat(d['Y']);
    
    const x = !isNaN(savedX) && isFixed ? savedX : Math.random() * (canvas.width/devicePixelRatio);
    const y = !isNaN(savedY) && isFixed ? savedY : Math.random() * (canvas.height/devicePixelRatio);
    
    return {
      id, 
      name: id, 
      raw: d, 
      show,
      isFixed,
      image: d['Image'] ? d['Image'].trim() : null, 
      imageBitmap: null,
      x, 
      y,
      fx: isFixed ? x : null,
      fy: isFixed ? y : null,
      unfixedX: null,
      unfixedY: null,
      vx: 0, 
      vy: 0, 
      r: CONFIG.sizeMin
    };
  }

  function processLinksData(connectionsData) {
    const tmpLinks = connectionsData.map(r => ({
      sourceName: (r['A']||'').toString().trim(),
      targetName: (r['B']||'').toString().trim(),
      value: +((r['Link Size']||r['LinkSize']) || 1) || 1,
      source: (r['Source']||'').toString().trim()
    })).filter(l => l.sourceName && l.targetName);

    // Add missing nodes from links
    tmpLinks.forEach(l => {
      if (!nodeById.has(l.sourceName)) {
        const n = { 
          id: l.sourceName, 
          name: l.sourceName, 
          raw: {}, 
          show: true,
          isFixed: false,
          image: null, 
          imageBitmap: null, 
          x: Math.random() * canvas.width, 
          y: Math.random() * canvas.height, 
          fx: null,
          fy: null,
          unfixedX: null,
          unfixedY: null,
          vx: 0, 
          vy: 0, 
          r: CONFIG.sizeMin 
        };
        nodes.push(n); 
        nodeById.set(n.id, n);
      }
      if (!nodeById.has(l.targetName)) {
        const n = { 
          id: l.targetName, 
          name: l.targetName, 
          raw: {}, 
          show: true,
          isFixed: false,
          image: null, 
          imageBitmap: null, 
          x: Math.random() * canvas.width, 
          y: Math.random() * canvas.height,
          fx: null,
          fy: null,
          unfixedX: null,
          unfixedY: null,
          vx: 0, 
          vy: 0, 
          r: CONFIG.sizeMin 
        };
        nodes.push(n); 
        nodeById.set(n.id, n);
      }
    });

    links = tmpLinks.map(l => ({ 
      source: nodeById.get(l.sourceName), 
      target: nodeById.get(l.targetName), 
      value: l.value,
      sourceUrl: l.source
    })).filter(l => l.source && l.target);
  }

  function buildAdjacency() {
    adjacency = new Map(); 
    connectionSources = new Map();
    nodes.forEach(n => {
      adjacency.set(n.id, new Set());
      connectionSources.set(n.id, new Map());
    });
    links.forEach(l => {
      adjacency.get(l.source.id).add(l.target.id);
      adjacency.get(l.target.id).add(l.source.id);
      
      if (l.sourceUrl) {
        connectionSources.get(l.source.id).set(l.target.id, l.sourceUrl);
        connectionSources.get(l.target.id).set(l.source.id, l.sourceUrl);
      }
    });
  }

  function updateNodeSizes() {
    const minSize = formattingSettings.minNodeSize;
    const maxSize = formattingSettings.maxNodeSize;
    
    if (formattingSettings.nodeSizeMode === 'custom') {
      // Use custom size for all nodes
      const customSize = formattingSettings.customNodeSize;
      nodes.forEach(n => {
        n.baseR = customSize;
      });
    } else {
      // Calculate size based on connections: 250 * (N / T)
      // N = Number of connections for entity
      // T = Total number of connections for all entities
      
      // Calculate total connections across all entities
      let totalConnections = 0;
      nodes.forEach(n => {
        const connections = adjacency.get(n.id);
        totalConnections += connections ? connections.size : 0;
      });
      
      // Avoid division by zero
      if (totalConnections === 0) {
        nodes.forEach(n => {
          n.baseR = minSize; // Use minimum size
        });
        applyNodeSizeScale();
        return;
      }
      
      // Calculate size for each node
      nodes.forEach(n => {
        const connections = adjacency.get(n.id);
        const connectionCount = connections ? connections.size : 0;
        const size = 250 * (connectionCount / totalConnections);
        n.baseR = Math.max(minSize, Math.min(size, maxSize)); // Clamp between min and max
      });
    }
    
    applyNodeSizeScale();
  }

  function applyNodeSizeScale() {
    const scale = formattingSettings.sizeScale;
    nodes.forEach(n => {
      n.r = (n.baseR || 15) * scale;
    });
  }

  function loadAllImages() {
    const imgNodes = nodes.filter(n => n.image && CONFIG.showImages);
    Promise.allSettled(imgNodes.map(n => loadImage(n))).then(() => render());
  }

  function loadImage(node) {
    return new Promise(async resolve => {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000);
        const resp = await fetch(node.image, { mode: 'cors', signal: controller.signal }).catch(()=>null);
        clearTimeout(timeoutId);
        if (!resp || !resp.ok) throw new Error('fetch failed');
        const blob = await resp.blob();
        if (typeof createImageBitmap === 'function') {
          const bmp = await createImageBitmap(blob, { resizeQuality: 'high' });
          node.imageBitmap = bmp;
          resolve();
        } else {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => { node.imageBitmap = img; resolve(); };
          img.onerror = () => { node.imageBitmap = null; resolve(); };
          img.src = URL.createObjectURL(blob);
        }
      } catch (err) {
        // Try direct image load as fallback
        try {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => { node.imageBitmap = img; resolve(); };
          img.onerror = () => { node.imageBitmap = null; resolve(); };
          img.src = node.image;
        } catch (e) {
          node.imageBitmap = null;
          resolve();
        }
      }
    });
  }

  /************************************************************************
   * ENTITY TABLE
   ************************************************************************/
  function updateEntityTable() {
    const tableEl = document.getElementById('entity-table');
    
    if (nodes.length === 0) {
      tableEl.innerHTML = '<div class="empty-state">Upload CSVs to get started</div>';
      return;
    }
    
    tableEl.innerHTML = '';
    
    nodes.forEach(node => {
      const row = document.createElement('div');
      row.className = 'entity-row';
      if (selectedNode && selectedNode.id === node.id) {
        row.classList.add('selected');
      }
      
      // Name
      const nameEl = document.createElement('div');
      nameEl.className = 'entity-name';
      nameEl.textContent = node.name;
      nameEl.title = node.name;
      nameEl.addEventListener('click', () => {
        selectedNode = node;
        populateInfoPanel(node);
        updateEntityTable();
        render();
      });
      row.appendChild(nameEl);
      
      // Show checkbox
      const showCell = document.createElement('div');
      showCell.style.textAlign = 'center';
      const showCheck = document.createElement('input');
      showCheck.type = 'checkbox';
      showCheck.className = 'entity-checkbox';
      showCheck.checked = node.show;
      showCheck.addEventListener('change', (e) => {
        node.show = e.target.checked;
        markDirty();
        schedulePhysicsRestart();
      });
      showCell.appendChild(showCheck);
      row.appendChild(showCell);
      
      // Fixed checkbox
      const fixedCell = document.createElement('div');
      fixedCell.style.textAlign = 'center';
      const fixedCheck = document.createElement('input');
      fixedCheck.type = 'checkbox';
      fixedCheck.className = 'entity-checkbox';
      fixedCheck.checked = node.isFixed;
      fixedCheck.addEventListener('change', (e) => {
        toggleFixed(node, e.target.checked);
      });
      fixedCell.appendChild(fixedCheck);
      row.appendChild(fixedCell);
      
      tableEl.appendChild(row);
    });
  }

  function toggleAllShow(show) {
    nodes.forEach(n => n.show = show);
    markDirty();
    updateEntityTable();
    schedulePhysicsRestart();
  }

  function toggleFixed(node, isFixed) {
    if (isFixed) {
      // Fix the node
      node.isFixed = true;
      node.fx = node.x;
      node.fy = node.y;
    } else {
      // Unfix the node
      node.isFixed = false;
      if (node.unfixedX !== null && node.unfixedY !== null) {
        node.x = node.unfixedX;
        node.y = node.unfixedY;
      }
      node.fx = null;
      node.fy = null;
    }
    
    markDirty();
    schedulePhysicsRestart();
  }

  /************************************************************************
   * PHYSICS
   ************************************************************************/
  let physicsTimer = null;

  function schedulePhysicsRestart() {
    clearTimeout(physicsTimer);
    physicsTimer = setTimeout(() => {
      updatePhysics();
    }, 100);
  }

  function updatePhysics() {
    if (simulation) simulation.stop();
    
    const visibleNodes = nodes.filter(n => n.show);
    const visibleLinks = links.filter(l => l.source.show && l.target.show);
    
    if (visibleNodes.length === 0) {
      render();
      return;
    }
    
    simulation = d3.forceSimulation(visibleNodes)
      .force('link', d3.forceLink(visibleLinks)
        .id(d => d.id)
        .distance(d => Math.max(20, CONFIG.force.linkDistance / Math.sqrt(Math.max(0.5, d.value))))
        .strength(CONFIG.force.linkStrength))
      .force('charge', d3.forceManyBody().strength(CONFIG.force.chargeStrength))
      .force('center', d3.forceCenter(
        (canvas.width/devicePixelRatio)/2, 
        (canvas.height/devicePixelRatio)/2
      ))
      .force('collision', d3.forceCollide().radius(d => d.r + CONFIG.force.collisionPadding))
      .velocityDecay(CONFIG.force.velocityDecay)
      .on('tick', () => {
        visibleNodes.forEach(n => {
          n.x = Math.max(n.r + PADDING, Math.min((canvas.width/devicePixelRatio) - n.r - PADDING, n.x));
          n.y = Math.max(n.r + PADDING, Math.min((canvas.height/devicePixelRatio) - n.r - PADDING, n.y));
          
          // Save unfixed positions
          if (!n.isFixed) {
            n.unfixedX = n.x;
            n.unfixedY = n.y;
          }
        });
        render();
      });
    
    simulation.alpha(0.3).restart();
  }

  /************************************************************************
   * DOWNLOAD
   ************************************************************************/
  function handleDownload() {
    if (nodes.length === 0) {
      showStatus('No data to download', 'error');
      return;
    }
    
    const entitiesCSV = generateEntitiesCSV();
    const connectionsCSV = generateConnectionsCSV();
    const formattingCSV = generateFormattingCSV();
    
    downloadCSV(entitiesCSV, 'Entities.csv');
    setTimeout(() => {
      downloadCSV(connectionsCSV, 'Connections.csv');
    }, 100);
    setTimeout(() => {
      downloadCSV(formattingCSV, 'Formatting.csv');
    }, 200);
    
    hasUnsavedChanges = false;
    updateDownloadButton();
    showStatus('CSVs downloaded successfully', 'success');
  }

  function generateEntitiesCSV() {
    const data = nodes.map(n => ({
      'Entity Name': n.name,
      'Description': n.raw['Description'] || '',
      'Category': n.raw['Category'] || '',
      'Area': n.raw['Area'] || '',
      'Sub Area': n.raw['Sub Area'] || '',
      'Image': n.raw['Image'] || '',
      'Link': n.raw['Link'] || '',
      'More Info': n.raw['More Info'] || '',
      'Show': n.show,
      'Fixed': n.isFixed,
      'X': n.isFixed ? n.x.toFixed(2) : '',
      'Y': n.isFixed ? n.y.toFixed(2) : ''
    }));
    
    return Papa.unparse(data);
  }

  function generateConnectionsCSV() {
    const data = links.map(l => ({
      'A': l.source.id || l.source,
      'B': l.target.id || l.target,
      'Link Size': l.value || 1,
      'Source': l.sourceUrl || ''
    }));
    
    return Papa.unparse(data);
  }
  
  function generateFormattingCSV() {
    const data = [];
    
    // First row: default formatting
    data.push({
      'RuleType': 'Default',
      'RuleName': '',
      'Order': '',
      'Targets': '',
      'NodeColor': formattingSettings.nodeColor,
      'NodeHoverColor': formattingSettings.nodeHoverColor,
      'OutlineColor': formattingSettings.outlineColor,
      'OutlineHoverColor': formattingSettings.outlineHoverColor,
      'OutlineThickness': formattingSettings.outlineThickness,
      'OutlineHoverThickness': formattingSettings.outlineHoverThickness,
      'NodeSize': '',
      'LineColor': formattingSettings.lineColor,
      'LineHoverColor': formattingSettings.lineHoverColor,
      'LineThickness': formattingSettings.lineThickness,
      'LineHoverThickness': formattingSettings.lineHoverThickness,
      'BackgroundColor': formattingSettings.backgroundColor,
      'ChartBorderX1': chartBorderArea ? chartBorderArea.x1 : '',
      'ChartBorderY1': chartBorderArea ? chartBorderArea.y1 : '',
      'ChartBorderX2': chartBorderArea ? chartBorderArea.x2 : '',
      'ChartBorderY2': chartBorderArea ? chartBorderArea.y2 : ''
    });
    
    // Add conditional format rules
    conditionalFormats.forEach((rule, index) => {
      data.push({
        'RuleType': rule.type === 'entity' ? 'Entity' : 'Category',
        'RuleName': rule.name,
        'Order': index,
        'Targets': rule.targets.join('|'),
        'NodeColor': rule.nodeColor || '',
        'NodeHoverColor': '',
        'OutlineColor': rule.outlineColor || '',
        'OutlineHoverColor': '',
        'OutlineThickness': rule.outlineThickness || '',
        'OutlineHoverThickness': '',
        'NodeSize': rule.nodeSize || '',
        'LineColor': rule.lineColor || '',
        'LineHoverColor': '',
        'LineThickness': rule.lineThickness || '',
        'LineHoverThickness': '',
        'BackgroundColor': '',
        'ChartBorderX1': '',
        'ChartBorderY1': '',
        'ChartBorderX2': '',
        'ChartBorderY2': ''
      });
    });
    
    return Papa.unparse(data);
  }

  function downloadCSV(csvContent, filename) {
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    
    link.setAttribute('href', url);
    link.setAttribute('download', filename);
    link.style.visibility = 'hidden';
    
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    URL.revokeObjectURL(url);
  }

  function markDirty() {
    hasUnsavedChanges = true;
    updateDownloadButton();
  }

  function updateDownloadButton() {
    if (hasUnsavedChanges) {
      downloadBtn.classList.add('unsaved');
      downloadBtn.title = 'You have unsaved changes - Download CSVs';
    } else {
      downloadBtn.classList.remove('unsaved');
      downloadBtn.title = 'Download/Save';
    }
  }

  // Warn before leaving with unsaved changes
  window.addEventListener('beforeunload', (e) => {
    if (hasUnsavedChanges && nodes.length > 0) {
      e.preventDefault();
      e.returnValue = 'You have unsaved changes. Download CSVs before leaving?';
      return e.returnValue;
    }
  });

  /************************************************************************
   * GRID SNAPPING
   ************************************************************************/
    function snapToGrid(x, y) {
    const width = canvas.width / devicePixelRatio;
    const height = canvas.height / devicePixelRatio;
    const centerX = width / 2 + panX * zoomLevel;
    const centerY = height / 2 + panY * zoomLevel;
    const gs = 25; // your new grid size

    return {
        x: Math.round((x - centerX) / gs) * gs + centerX,
        y: Math.round((y - centerY) / gs) * gs + centerY
    };
    }

    function drawGrid() {
    const width = canvas.width / devicePixelRatio;
    const height = canvas.height / devicePixelRatio;
    
    const centerX = width / 2 + panX * zoomLevel;
    const centerY = height / 2 + panY * zoomLevel;
    
    ctx.save();
    
    // Draw regular grid lines
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.25)';
    ctx.lineWidth = 1 / zoomLevel;
    
    // Vertical lines from center
    for (let dx = 0; dx <= width; dx += CONFIG.gridSize) {
        // Right of center
        let xRight = centerX + dx;
        if (xRight <= width) {
        ctx.beginPath();
        ctx.moveTo(xRight, 0);
        ctx.lineTo(xRight, height);
        ctx.stroke();
        }
        // Left of center
        if (dx > 0) { // avoid drawing center twice
        let xLeft = centerX - dx;
        if (xLeft >= 0) {
            ctx.beginPath();
            ctx.moveTo(xLeft, 0);
            ctx.lineTo(xLeft, height);
            ctx.stroke();
        }
        }
    }

    // Horizontal lines from center
    for (let dy = 0; dy <= height; dy += CONFIG.gridSize) {
        // Below center
        let yDown = centerY + dy;
        if (yDown <= height) {
        ctx.beginPath();
        ctx.moveTo(0, yDown);
        ctx.lineTo(width, yDown);
        ctx.stroke();
        }
        // Above center
        if (dy > 0) {
        let yUp = centerY - dy;
        if (yUp >= 0) {
            ctx.beginPath();
            ctx.moveTo(0, yUp);
            ctx.lineTo(width, yUp);
            ctx.stroke();
        }
        }
    }
    
    // Draw thicker center lines
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
    ctx.lineWidth = 2 / zoomLevel;
    
    // Vertical center line
    ctx.beginPath();
    ctx.moveTo(centerX, 0);
    ctx.lineTo(centerX, height);
    ctx.stroke();
    
    // Horizontal center line
    ctx.beginPath();
    ctx.moveTo(0, centerY);
    ctx.lineTo(width, centerY);
    ctx.stroke();
    
    ctx.restore();
    }


  /************************************************************************
   * RENDERING
   ************************************************************************/
  function clearCanvas() {
    ctx.fillStyle = formattingSettings.backgroundColor;
    ctx.fillRect(0, 0, canvas.width/devicePixelRatio, canvas.height/devicePixelRatio);
  }

  function applyTransform() {
    const centerX = (canvas.width/devicePixelRatio) / 2;
    const centerY = (canvas.height/devicePixelRatio) / 2;
    ctx.translate(centerX + panX, centerY + panY);
    ctx.scale(zoomLevel, zoomLevel);
    ctx.translate(-centerX, -centerY);
  }

  function roundRectPath(x, y, w, h, r) {
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
  }

  function drawLink(l, opacity) {
    ctx.save();
    ctx.globalAlpha = opacity;
    
    // Get formatting for this link (conditional or default)
    const format = getLinkFormat(l);
    
    // Check if either end of the link is hovered
    const isHovered = hoveredNode && (l.source === hoveredNode || l.target === hoveredNode);
    
    // Use hover colors/thickness if link is connected to hovered node
    const lineColor = isHovered ? formattingSettings.lineHoverColor : (format?.lineColor || formattingSettings.lineColor);
    const lineThickness = isHovered ? formattingSettings.lineHoverThickness : (format?.lineThickness || formattingSettings.lineThickness);
    
    ctx.beginPath();
    ctx.moveTo(l.source.x, l.source.y);
    ctx.lineTo(l.target.x, l.target.y);
    ctx.lineWidth = lineThickness / zoomLevel;
    ctx.strokeStyle = lineColor;
    ctx.stroke();
    ctx.restore();
  }

  function drawNode(n, opacity, showImage=true) {
    ctx.save();
    const x = n.x, y = n.y;
    
    // Get formatting for this node (conditional or default)
    const format = getNodeFormat(n);
    const isHovered = hoveredNode && n === hoveredNode;
    const isSelected = selectedNode && n === selectedNode;
    
    // Use hover colors/thickness if node is hovered OR selected
    const nodeColor = isHovered ? formattingSettings.nodeHoverColor : (format?.nodeColor || formattingSettings.nodeColor);
    const outlineColor = (isHovered || isSelected) ? formattingSettings.outlineHoverColor : (format?.outlineColor || formattingSettings.outlineColor);
    const outlineThickness = (isHovered || isSelected) ? formattingSettings.outlineHoverThickness : (format?.outlineThickness || formattingSettings.outlineThickness);
    
    // Apply custom size if specified in conditional format
    let r = n.r;
    if (format?.nodeSize) {
      r = (format.nodeSize * formattingSettings.sizeScale) / 2;
    }

    if (showImage && n.imageBitmap) {
      ctx.save();
      ctx.globalAlpha = opacity;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI*2);
      ctx.clip();
      const img = n.imageBitmap;
      const iw = img.width || img.naturalWidth || 1;
      const ih = img.height || img.naturalHeight || 1;
      const target = r * 2;
      const scale = Math.max(target / iw, target / ih);
      const dw = iw * scale;
      const dh = ih * scale;
      const dx = x - dw / 2;
      const dy = y - dh / 2;
      try {
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        ctx.drawImage(img, dx, dy, dw, dh);
      } catch (e) {
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI*2);
        ctx.fillStyle = nodeColor;
        ctx.fill();
      }
      ctx.restore();
    } else {
      ctx.save();
      ctx.globalAlpha = opacity;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI*2);
      ctx.fillStyle = nodeColor;
      ctx.fill();
      ctx.restore();
    }

    // Draw outline with glow if this is the selected node
    ctx.save();
    ctx.globalAlpha = opacity;
    
    // Add pulsing glow for selected node
    if (selectedNode && n === selectedNode) {
      const pulsePhase = Math.sin(animationTime * 0.002) * 0.5 + 0.5; // Oscillates between 0 and 1
      const glowSize = 5 + pulsePhase * 10; // Varies between 5 and 15
      const glowAlpha = 0.5 + pulsePhase * 0.5; // Varies between 0.5 and 1
      
      // Convert hover outline color to rgba for glow effect
      const hoverColor = formattingSettings.outlineHoverColor;
      const r = parseInt(hoverColor.slice(1, 3), 16);
      const g = parseInt(hoverColor.slice(3, 5), 16);
      const b = parseInt(hoverColor.slice(5, 7), 16);
      
      ctx.shadowColor = `rgba(${r}, ${g}, ${b}, ${glowAlpha})`;
      ctx.shadowBlur = glowSize;
    }
    
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI*2);
    ctx.lineWidth = outlineThickness / zoomLevel;
    ctx.strokeStyle = outlineColor;
    ctx.stroke();
    ctx.restore();

    ctx.restore();
  }

  function drawLabel(n) {
    const text = n.name || '';
    if (!text) return;
    ctx.save();
    ctx.font = `${CONFIG.labelFontSize / zoomLevel}px Rubik, Arial, sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    const metrics = ctx.measureText(text);
    const textW = metrics.width;
    const pad = CONFIG.labelBoxPadding / zoomLevel;
    const boxW = textW + pad * 2;
    const boxH = (CONFIG.labelFontSize + 6) / zoomLevel;
    const x = n.x - boxW / 2;
    const y = n.y + n.r + CONFIG.labelOffsetY / zoomLevel;

    ctx.save();
    ctx.globalAlpha = CONFIG.labelBoxOpacity;
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    roundRectPath(x, y, boxW, boxH, 6 / zoomLevel);
    ctx.fill();
    ctx.restore();

    ctx.fillStyle = '#111827';
    ctx.fillText(text, n.x, y + boxH / 2);
    ctx.restore();
  }

  function shouldHighlightNode(node) {
    if (!selectedNode) return true;
    const activeSet = new Set([selectedNode.id, ...(adjacency.get(selectedNode.id) || [])]);
    return activeSet.has(node.id);
  }

  /************************************************************************
   * CHART BORDER DRAWING
   ************************************************************************/
  function drawChartBorder() {
    if (!chartBorderArea) return;
    
    ctx.save();
    ctx.strokeStyle = '#020202';
    ctx.lineWidth = 2 / zoomLevel;
    ctx.setLineDash([10 / zoomLevel, 5 / zoomLevel]);
    
    const x1 = Math.min(chartBorderArea.x1, chartBorderArea.x2);
    const y1 = Math.min(chartBorderArea.y1, chartBorderArea.y2);
    const x2 = Math.max(chartBorderArea.x1, chartBorderArea.x2);
    const y2 = Math.max(chartBorderArea.y1, chartBorderArea.y2);
    
    ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
    
    ctx.restore();
  }

  function drawChartBorderPreview() {
    if (!chartBorderStartPoint || !chartBorderPreviewEnd) return;
    
    ctx.save();
    ctx.strokeStyle = '#020202';
    ctx.lineWidth = 2 / zoomLevel;
    ctx.setLineDash([10 / zoomLevel, 5 / zoomLevel]);
    
    const x1 = Math.min(chartBorderStartPoint.x, chartBorderPreviewEnd.x);
    const y1 = Math.min(chartBorderStartPoint.y, chartBorderPreviewEnd.y);
    const x2 = Math.max(chartBorderStartPoint.x, chartBorderPreviewEnd.x);
    const y2 = Math.max(chartBorderStartPoint.y, chartBorderPreviewEnd.y);
    
    ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
    
    ctx.restore();
  }

  function render() {
    animationTime = Date.now();
    clearCanvas();
    if (!nodes || nodes.length === 0) return;

    ctx.save();
    applyTransform();

    const visibleNodes = nodes.filter(n => n.show);
    const highlightedNodes = [];
    const unhighlightedNodes = [];
    
    visibleNodes.forEach(node => {
      if (shouldHighlightNode(node)) {
        highlightedNodes.push(node);
      } else {
        unhighlightedNodes.push(node);
      }
    });

    unhighlightedNodes.forEach(n => drawNode(n, CONFIG.unconnectedOpacity, CONFIG.showImages));

    const highlightedSet = new Set(highlightedNodes.map(n => n.id));
    const visibleLinks = links.filter(l => l.source.show && l.target.show);
    
    if (selectedNode) {
      visibleLinks.forEach(l => {
        if (highlightedSet.has(l.source.id) && highlightedSet.has(l.target.id)) {
          drawLink(l, CONFIG.linkOpacitySelected);
        }
      });
    } else {
      visibleLinks.forEach(l => {
        drawLink(l, CONFIG.linkOpacityNoSelection);
      });
    }

    highlightedNodes.forEach(n => drawNode(n, CONFIG.pointOpacity, CONFIG.showImages));

    // Draw grid OVER nodes when dragging or drawing chart border
    if (isDraggingNode || isDrawingChartBorder) {
      ctx.restore();
      ctx.save();
      applyTransform();
      drawGrid();
    }

    // Draw chart border
    drawChartBorder();
    
    // Draw chart border preview
    if (isDrawingChartBorder) {
      drawChartBorderPreview();
    }

    if (selectedNode) {
      highlightedNodes.forEach(n => {
        if (adjacency.get(selectedNode.id).has(n.id) || n === selectedNode) {
          drawLabel(n);
        }
      });
    }

    if (hoveredNode && hoveredNode !== selectedNode && hoveredNode.show) {
      drawLabel(hoveredNode);
    }

    ctx.restore();
    
    // Schedule next animation frame only if a node is selected
    // Use throttled approach to reduce CPU usage
    if (selectedNode && !animationScheduled) {
      animationScheduled = true;
      setTimeout(() => {
        animationScheduled = false;
        requestAnimationFrame(render);
      }, 50); // ~20 FPS for smooth animation with less CPU usage
    }
  }

  /************************************************************************
   * CANVAS INTERACTION
   ************************************************************************/
  function getCanvasPos(evt) {
    const rect = canvas.getBoundingClientRect();
    const x = (evt.clientX - rect.left) * (canvas.width / devicePixelRatio) / rect.width;
    const y = (evt.clientY - rect.top) * (canvas.height / devicePixelRatio) / rect.height;
    
    const centerX = (canvas.width/devicePixelRatio) / 2;
    const centerY = (canvas.height/devicePixelRatio) / 2;
    
    const transformedX = (x - centerX - panX) / zoomLevel + centerX;
    const transformedY = (y - centerY - panY) / zoomLevel + centerY;
    
    return { x: transformedX, y: transformedY };
  }

  function findNodeAtPos(x, y) {
    if (!nodes || nodes.length === 0) return null;
    const visibleNodes = nodes.filter(n => n.show);
    
    if (selectedNode) {
      const activeSet = new Set([selectedNode.id, ...(adjacency.get(selectedNode.id) || [])]);
      const activeNodes = visibleNodes.filter(n => activeSet.has(n.id));
      for (let i = activeNodes.length - 1; i >= 0; i--) {
        const n = activeNodes[i];
        if (Math.hypot(n.x - x, n.y - y) <= n.r) return n;
      }
      const otherNodes = visibleNodes.filter(n => !activeSet.has(n.id));
      for (let i = otherNodes.length - 1; i >= 0; i--) {
        const n = otherNodes[i];
        if (Math.hypot(n.x - x, n.y - y) <= n.r) return n;
      }
    } else {
      for (let i = visibleNodes.length - 1; i >= 0; i--) {
        const n = visibleNodes[i];
        if (Math.hypot(n.x - x, n.y - y) <= n.r) return n;
      }
    }
    return null;
  }

  function updateCanvasCursor() {
    if (isDrawingChartBorder) {
      canvas.style.cursor = 'crosshair';
    } else if (isDragging || isDraggingNode) {
      canvas.style.cursor = 'grabbing';
    } else if (zoomLevel > 1.0) {
      canvas.style.cursor = 'grab';
    } else {
      canvas.style.cursor = 'default';
    }
  }

  canvas.addEventListener('mousedown', (evt) => {
    // Prevent interaction if in export mode (except for drawing)
    if (isExportMode && !isDrawingChartBorder) {
      return;
    }
    
    didDrag = false; // Reset drag flag for new interaction
    const pos = getCanvasPos(evt);
    
    // Handle chart border drawing
    if (isDrawingChartBorder) {
      if (!chartBorderStartPoint) {
        // First click - set start point
        const snapped = snapToGrid(pos.x, pos.y);
        chartBorderStartPoint = snapped;
        chartBorderPreviewEnd = snapped;
        render();
      } else {
        // Second click - complete the rectangle
        const snapped = snapToGrid(pos.x, pos.y);
        chartBorderArea = {
          x1: chartBorderStartPoint.x,
          y1: chartBorderStartPoint.y,
          x2: snapped.x,
          y2: snapped.y
        };
        
        // Exit drawing mode
        isDrawingChartBorder = false;
        chartBorderStartPoint = null;
        chartBorderPreviewEnd = null;
        
        // If in export mode, show export controls
        if (isExportMode) {
          // Calculate center of the drawn rectangle in screen coordinates
          const rect = canvas.getBoundingClientRect();
          const centerWorldX = (chartBorderArea.x1 + chartBorderArea.x2) / 2;
          const centerWorldY = (chartBorderArea.y1 + chartBorderArea.y2) / 2;
          
          // Transform to screen coordinates
          const centerX = (canvas.width/devicePixelRatio) / 2;
          const centerY = (canvas.height/devicePixelRatio) / 2;
          const screenX = ((centerWorldX - centerX) * zoomLevel + panX + centerX) * rect.width / (canvas.width / devicePixelRatio);
          const screenY = ((centerWorldY - centerY) * zoomLevel + panY + centerY) * rect.height / (canvas.height / devicePixelRatio);
          
          showExportControls(rect.left + screenX - 150, rect.top + screenY - 25);
        } else {
          markDirty();
        }
        
        updateCanvasCursor();
        render();
      }
      return;
    }
    
    const n = findNodeAtPos(pos.x, pos.y);
    
    if (n) {
      // Start potential node drag with delay
      mouseDownNode = n;
      mouseDownTime = Date.now();
      
    dragDelayTimer = setTimeout(() => {
    if (mouseDownNode === n) {
        // Stop physics during drag
        if (simulation) simulation.stop();
        
        // Deselect any currently selected node immediately
        selectedNode = null;
        clearInfoPanel();
        updateEntityTable();

        isDraggingNode = true;
        draggedNode = n;
        
        // Save unfixed position before dragging
        if (!n.isFixed) {
        n.unfixedX = n.x;
        n.unfixedY = n.y;
        }
        
        updateCanvasCursor();
        render();
    }
    }, CONFIG.dragDelayMs);

      
      evt.preventDefault();
    } else if (zoomLevel > 1.0) {
      // Panning canvas
      isDragging = true;
      dragStartX = evt.clientX;
      dragStartY = evt.clientY;
      dragStartPanX = panX;
      dragStartPanY = panY;
      updateCanvasCursor();
      evt.preventDefault();
    }
  });

  canvas.addEventListener('mousemove', (evt) => {
    // Only allow drawing preview in export mode
    if (isExportMode && !isDrawingChartBorder) {
      return;
    }
    
    // Handle chart border drawing preview
    if (isDrawingChartBorder && chartBorderStartPoint) {
      const pos = getCanvasPos(evt);
      const snapped = snapToGrid(pos.x, pos.y);
      chartBorderPreviewEnd = snapped;
      render();
      return;
    }
    
    if (isDraggingNode && draggedNode) {
      didDrag = true; // Mark that actual dragging occurred
      const pos = getCanvasPos(evt);
      draggedNode.x = pos.x;
      draggedNode.y = pos.y;
      render();
      evt.preventDefault();
    } else if (isDragging && zoomLevel > 1.0) {
      didDrag = true; // Mark that actual dragging occurred
      const deltaX = evt.clientX - dragStartX;
      const deltaY = evt.clientY - dragStartY;
      panX = dragStartPanX + deltaX / zoomLevel;
      panY = dragStartPanY + deltaY / zoomLevel;
      render();
      evt.preventDefault();
    } else {
      // Hover effect
      const pos = getCanvasPos(evt);
      const n = findNodeAtPos(pos.x, pos.y);
      if (n !== hoveredNode) {
        hoveredNode = n;
        render();
      }
    }
  });

  canvas.addEventListener('mouseup', (evt) => {
    // Clear drag delay timer
    if (dragDelayTimer) {
      clearTimeout(dragDelayTimer);
      dragDelayTimer = null;
    }
    
    if (isDraggingNode && draggedNode) {
      // Snap to grid
      const snapped = snapToGrid(draggedNode.x, draggedNode.y);
      draggedNode.x = snapped.x;
      draggedNode.y = snapped.y;
      
      // Auto-fix the node
      draggedNode.isFixed = true;
      draggedNode.fx = snapped.x;
      draggedNode.fy = snapped.y;
      
      markDirty();
      updateEntityTable();
      schedulePhysicsRestart();
      
      isDraggingNode = false;
      draggedNode = null;
      mouseDownNode = null;
      updateCanvasCursor();
      evt.preventDefault();
    } else if (isDragging) {
      const deltaX = Math.abs(evt.clientX - dragStartX);
      const deltaY = Math.abs(evt.clientY - dragStartY);
      
      isDragging = false;
      updateCanvasCursor();
      
      if (deltaX < 3 && deltaY < 3) {
        const pos = getCanvasPos(evt);
        const n = findNodeAtPos(pos.x, pos.y);
        if (n) {
          selectedNode = n;
          populateInfoPanel(n);
          updateEntityTable();
          render();
        } else {
          selectedNode = null;
          clearInfoPanel();
          updateEntityTable();
          render();
        }
      }
      evt.preventDefault();
    } else if (mouseDownNode) {
      // Quick click without drag
      const timeSinceDown = Date.now() - mouseDownTime;
      if (timeSinceDown < CONFIG.dragDelayMs) {
        const pos = getCanvasPos(evt);
        const n = findNodeAtPos(pos.x, pos.y);
        if (n && n === mouseDownNode) {
          selectedNode = n;
          populateInfoPanel(n);
          updateEntityTable();
          render();
        }
      }
      mouseDownNode = null;
    }
  });

  canvas.addEventListener('click', (evt) => {
    if (didDrag) {
        didDrag = false;
        evt.preventDefault();
        return; // skip click logic after dragging
    }
    if (isDragging || isDraggingNode) return;
    const pos = getCanvasPos(evt);
    const n = findNodeAtPos(pos.x, pos.y);
    if (n) {
      selectedNode = n;
      populateInfoPanel(n);
      updateEntityTable();
      render();
    } else {
      selectedNode = null;
      clearInfoPanel();
      updateEntityTable();
      render();
    }
  });

  canvas.addEventListener('mouseleave', (evt) => {
    if (dragDelayTimer) {
      clearTimeout(dragDelayTimer);
      dragDelayTimer = null;
    }
    
    isDragging = false;
    didDrag = false; // Reset drag flag when leaving canvas
    if (isDraggingNode) {
      // Restart physics if we were dragging
      schedulePhysicsRestart();
    }
    isDraggingNode = false;
    draggedNode = null;
    mouseDownNode = null;
    updateCanvasCursor();
    if (hoveredNode) {
      hoveredNode = null;
      render();
    }
  });

  /************************************************************************
   * ZOOM CONTROLS
   ************************************************************************/
  function zoomIn() {
    zoomLevel = Math.min(CONFIG.zoomMax, zoomLevel + CONFIG.zoomStep);
    updateCanvasCursor();
    render();
  }
  
  function zoomOut() {
    zoomLevel = Math.max(CONFIG.zoomMin, zoomLevel - CONFIG.zoomStep);
    updateCanvasCursor();
    render();
  }
  
  function resetZoom() {
    zoomLevel = 1.0;
    panX = 0;
    panY = 0;
    updateCanvasCursor();
    render();
  }

  zoomInBtn.addEventListener('click', zoomIn);
  zoomOutBtn.addEventListener('click', zoomOut);
  zoomResetBtn.addEventListener('click', resetZoom);

  /************************************************************************
   * EXPORT MODE FUNCTIONS
   ************************************************************************/
  function startExportMode() {
    if (isExportMode) return; // Already in export mode
    
    isExportMode = true;
    isDrawingChartBorder = true;
    chartBorderStartPoint = null;
    chartBorderPreviewEnd = null;
    
    // Disable other UI elements
    disableUIForExport();
    
    updateCanvasCursor();
    render();
  }

  function disableUIForExport() {
    // Add disabled overlay class to panels
    const entityManager = document.getElementById('entity-manager');
    const infoPanel = document.getElementById('info-panel');
    const zoomControls = document.getElementById('zoom-controls');
    
    entityManager.classList.add('disabled-overlay');
    infoPanel.classList.add('disabled-overlay');
    zoomControls.classList.add('disabled-overlay');
  }

  function enableUIAfterExport() {
    // Remove disabled overlay class from panels
    const entityManager = document.getElementById('entity-manager');
    const infoPanel = document.getElementById('info-panel');
    const zoomControls = document.getElementById('zoom-controls');
    
    entityManager.classList.remove('disabled-overlay');
    infoPanel.classList.remove('disabled-overlay');
    zoomControls.classList.remove('disabled-overlay');
  }

  function showExportControls(x, y) {
    exportControls.style.display = 'flex';
    exportControls.style.left = x + 'px';
    exportControls.style.top = y + 'px';
  }

  function hideExportControls() {
    exportControls.style.display = 'none';
  }


  /************************************************************************
   * EXPORT IFRAME GENERATION
   ************************************************************************/
  function serializeChartData() {
    // Serialize nodes with their current positions and formatting
    const serializedNodes = nodes.map(n => ({
      id: n.id,
      name: n.name,
      x: n.x,
      y: n.y,
      color: n.color || formattingSettings.nodeColor,
      size: n.size || formattingSettings.customNodeSize,
      labelSize: n.labelSize,
      labelColor: n.labelColor,
      image: n.image,
      raw: n.raw
    }));

    // Serialize links with their formatting
    const serializedLinks = links.map(l => ({
      source: typeof l.source === 'object' ? l.source.id : l.source,
      target: typeof l.target === 'object' ? l.target.id : l.target,
      color: l.color || formattingSettings.lineColor,
      width: l.width || formattingSettings.lineThickness
    }));

    return {
      nodes: serializedNodes,
      links: serializedLinks
    };
  }

  function calculateExportViewport() {
    if (!chartBorderArea) return { x: 0, y: 0, zoom: 1, width: 800, height: 600 };

    const { x1, y1, x2, y2 } = chartBorderArea;
    const width = Math.abs(x2 - x1);
    const height = Math.abs(y2 - y1);
    
    // Calculate the center of the selected area in canvas coordinates
    const centerX = (x1 + x2) / 2;
    const centerY = (y1 + y2) / 2;
    
    // Convert canvas coordinates to world coordinates
    const worldX = (centerX - panX) / zoomLevel;
    const worldY = (centerY - panY) / zoomLevel;
    
    // Calculate the zoom level needed to fit the selected area
    // We want the selected area to fill most of the export frame
    const margin = 50; // pixels of margin
    const targetWidth = width - (margin * 2);
    const targetHeight = height - (margin * 2);
    
    // The export zoom should make the content fit nicely
    const exportZoom = zoomLevel;
    
    // Calculate the translate values to center the selected area in the export
    // These will position the chart so the selected area appears centered
    const translateX = (width / 2) - (worldX * exportZoom);
    const translateY = (height / 2) - (worldY * exportZoom);
    
    return {
      x: translateX,
      y: translateY,
      zoom: exportZoom,
      width: Math.round(width),
      height: Math.round(height)
    };
  }

  function generateIframeCode() {
    const chartData = serializeChartData();
    const viewport = calculateExportViewport();
    
    const dataString = JSON.stringify(chartData);
    const dataSize = new Blob([dataString]).size;
    
    // URL has practical limit around 2000 chars for compatibility
    // If data is large, use localStorage approach
    let iframeUrl;
    
    if (dataSize > 1500) {
      // Use localStorage for large data
      const dataKey = 'chartData_' + Date.now();
      localStorage.setItem(dataKey, dataString);
      
      iframeUrl = `Export.html?dataKey=${dataKey}&x=${viewport.x}&y=${viewport.y}&zoom=${viewport.zoom}`;
    } else {
      // Use URL parameter for small data
      const base64Data = btoa(dataString);
      iframeUrl = `Export.html?data=${encodeURIComponent(base64Data)}&x=${viewport.x}&y=${viewport.y}&zoom=${viewport.zoom}`;
    }
    
    const iframeCode = `<iframe src="${iframeUrl}" width="${viewport.width}" height="${viewport.height}" frameborder="0" style="border: none;"></iframe>`;
    
    return iframeCode;
  }

  function copyToClipboard(text) {
    navigator.clipboard.writeText(text).then(() => {
      // Show success feedback
      const copyBtn = document.getElementById('copy-iframe-btn');
      if (copyBtn) {
        const originalText = copyBtn.textContent;
        copyBtn.textContent = 'Copied!';
        copyBtn.style.background = 'var(--main-yellow)';
        setTimeout(() => {
          copyBtn.textContent = originalText;
          copyBtn.style.background = '';
        }, 2000);
      }
    }).catch(err => {
      console.error('Failed to copy:', err);
      alert('Failed to copy to clipboard. Please copy manually.');
    });
  }

  function showExportOptions() {
    const iframeCode = generateIframeCode();
    
    // Update the export options content with the iframe code
    const exportOptionsContent = document.querySelector('.export-options-content');
    exportOptionsContent.innerHTML = `
      <div style="margin-bottom: 16px;">
        <label style="display: block; margin-bottom: 8px; font-weight: 700;">Embed Code:</label>
        <textarea id="iframe-code-textarea" readonly style="
          width: 100%;
          height: 120px;
          font-family: 'Courier New', monospace;
          font-size: 12px;
          padding: 12px;
          border: 1px solid var(--shadow-grey);
          border-radius: 6px;
          background: var(--highlight-white);
          color: var(--text-black);
          resize: vertical;
          box-sizing: border-box;
        ">${iframeCode}</textarea>
      </div>
      <button id="copy-iframe-btn" style="
        width: 100%;
        padding: 10px;
        background: var(--main-yellow);
        color: var(--text-black);
        border: 0px solid var(--main-yellow);
        border-radius: 6px;
        font-family: var(--font-family);
        font-size: 14px;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.2s;
      " 
      onmouseover="this.style.background='var(--light-yellow)'" onmouseout="this.style.background='var(--light-yellow)'">
        Copy to Clipboard
      </button>
    `;
    
    // Add click handler for copy button
    document.getElementById('copy-iframe-btn').addEventListener('click', () => {
      copyToClipboard(iframeCode);
    });
    
    exportOptionsModal.style.display = 'flex';
  }


  function closeExportOptions() {
    exportOptionsModal.style.display = 'none';
  }

  function redrawBorder() {
    hideExportControls();
    chartBorderArea = null;
    isDrawingChartBorder = true;
    chartBorderStartPoint = null;
    chartBorderPreviewEnd = null;
    updateCanvasCursor();
    render();
  }

  function cancelExport() {
    hideExportControls();
    isExportMode = false;
    isDrawingChartBorder = false;
    chartBorderStartPoint = null;
    chartBorderPreviewEnd = null;
    chartBorderArea = null;
    enableUIAfterExport();
    updateCanvasCursor();
    render();
  }

  /************************************************************************
   * INFO PANEL
   ************************************************************************/
  function normalizeUrl(u) {
    if (!u) return null;
    const s = String(u).trim();
    if (s === '') return null;
    if (/^[a-zA-Z][a-zA-Z0-9+\-.]*:\/\//.test(s)) return s;
    return 'https://' + s.replace(/^[\/]+/, '');
  }

  function populateInfoPanel(d) {
    const desc = (d.raw && (d.raw['Description'] || '')) || '';
    const category = (d.raw && (d.raw['Category'] || '')) || '';

    // Build the links FIRST
    const rawLink = (d.raw && (d.raw['Link'] || d.raw['Link '])) || '';
    const safe = normalizeUrl(rawLink);
    const rawMoreInfo = (d.raw && (d.raw['More Info'] || d.raw['More Info'])) || '';
    const safeMoreInfo = normalizeUrl(rawMoreInfo);

    let links = [];
    if (safe) links.push(`<a href="${safe}" target="_blank" rel="noopener">More Info</a>`);
    if (safeMoreInfo) links.push(`<a href="${safeMoreInfo}" target="_blank" rel="noopener">More Info</a>`);
    const linksHTML = links.length > 0 ? links.join(' | ') : '';

    // Now set the title area INCLUDING the links
    nodeTitleEl.html(`
      <div style="display:flex; align-items:center; gap:8px; font-size:24px; font-weight:700;">
        <span>${d.name}</span>
        ${d.image ? `<img src="${d.image}" style="width:40px; height:40px; object-fit:cover; border-radius:50%;">` : ''}
      </div>
      ${category ? `<div style="font-size: 15px; font-weight: bold; margin-top: 6px;">${category.replace(/\n/g, '<br>')}</div>` : ''}
      ${desc ? `<div style="font-size: 13px; font-weight: normal;">${desc}</div>` : ''}
      ${linksHTML ? `<div style="margin-top: 8px;">${linksHTML}</div>` : ''}
      <div style="font-size: 14px; font-weight: bold; margin-top: 6px;">
        <br>
        <br>Connected to: 
      </div>
    `);

    // Clear the old nodeLinkEl since we're not using it anymore
    nodeLinkEl.html('');

    const conns = Array.from(adjacency.get(d.id) || []).slice();
    conns.sort((a,b) => a.localeCompare(b, undefined, {sensitivity:'base'}));
    connectionsBox.innerHTML = '';
    if (conns.length === 0) {
      connectionsBox.innerHTML = '<div class="muted">No connections</div>';
      return;
    }
    const frag = document.createDocumentFragment();
    const nodeSourceMap = connectionSources.get(d.id);
    conns.forEach(name => {
      const item = document.createElement('div');
      item.className = 'conn-item';
      item.style.display = 'flex';
      item.style.alignItems = 'center';
      item.style.justifyContent = 'space-between';
      item.style.gap = '8px';
      
      const nameSpan = document.createElement('span');
      nameSpan.textContent = name;
      nameSpan.style.flex = '1';
      nameSpan.style.cursor = 'pointer';
      nameSpan.addEventListener('click', () => {
        const targetNode = nodeById.get(name);
        if (targetNode) {
          selectedNode = targetNode;
          populateInfoPanel(targetNode);
          updateEntityTable();
          render();
          connectionsBox.scrollTop = 0;
        }
      });
      item.appendChild(nameSpan);
      
      const sourceUrl = nodeSourceMap ? nodeSourceMap.get(name) : null;
      if (sourceUrl) {
        const sourceIcon = document.createElement('a');
        sourceIcon.href = normalizeUrl(sourceUrl) || '#';
        sourceIcon.target = '_blank';
        sourceIcon.rel = 'noopener';
        sourceIcon.innerHTML = '🔗';
        sourceIcon.style.fontSize = '16px';
        sourceIcon.style.textDecoration = 'none';
        sourceIcon.style.cursor = 'pointer';
        sourceIcon.style.flexShrink = '0';
        sourceIcon.title = 'View source';
        sourceIcon.addEventListener('click', (e) => {
          e.stopPropagation();
        });
        item.appendChild(sourceIcon);
      }
      
      frag.appendChild(item);
    });
    connectionsBox.appendChild(frag);
  }

  function clearInfoPanel() {
    nodeTitleEl.html('Select a node to view details');
    nodeMetaEl.text('');
    nodeLinkEl.html('');
    connectionsBox.innerHTML = '';
  }

  searchInput.addEventListener('input', onSearchInput);
  searchBtn.addEventListener('click', () => performSearch(searchInput.value.trim()));
  searchInput.addEventListener('keydown', (ev) => { 
    if (ev.key === 'Enter') { 
      performSearch(searchInput.value.trim()); 
      ev.preventDefault(); 
    } 
  });

  clearBtn.addEventListener('click', () => { 
    selectedNode = null; 
    clearInfoPanel(); 
    updateEntityTable();
    render(); 
    searchInput.value = ''; 
    suggestionsEl.style('display', 'none').html(''); 
    msgEl.text('');
  });

  function onSearchInput() {
    const q = searchInput.value.trim();
    suggestionsEl.style('display', 'none').html('');
    msgEl.text('');
    if (!q || q.length < 3) return;
    const term = q.toLowerCase();
    const matches = [];
    for (const name of nameIndex) {
      if (name && name.toLowerCase().includes(term)) matches.push(name);
      if (matches.length >= CONFIG.maxSuggestions) break;
    }
    if (matches.length === 0) {
      suggestionsEl.style('display','block').html('<div class="muted">No suggestions</div>');
      return;
    }
    suggestionsEl.style('display','block').html('');
    matches.forEach(m => {
      suggestionsEl.append('div').attr('class','suggestion').text(m).on('click', () => {
        searchInput.value = m;
        suggestionsEl.style('display','none').html('');
        performSearch(m);
      });
    });
  }

  function performSearch(q) {
    if (!q) return;
    const exact = nodes.find(n => n.name && n.name.toLowerCase() === q.toLowerCase());
    if (exact) {
      selectedNode = exact; 
      populateInfoPanel(exact); 
      updateEntityTable();
      render(); 
      msgEl.text(''); 
      return;
    }
    const matches = nodes.filter(n => n.name && n.name.toLowerCase().includes(q.toLowerCase()));
    if (matches.length === 1) {
      selectedNode = matches[0]; 
      populateInfoPanel(matches[0]); 
      updateEntityTable();
      render(); 
      msgEl.text(''); 
      return;
    } else if (matches.length > 1) {
      suggestionsEl.style('display','block').html('');
      matches.slice(0, CONFIG.maxSuggestions).forEach(m => {
        suggestionsEl.append('div').attr('class','suggestion').text(m.name).on('click', () => {
          searchInput.value = m.name;
          suggestionsEl.style('display','none').html('');
          selectedNode = m;
          populateInfoPanel(m);
          updateEntityTable();
          render();
        });
      });
      msgEl.text('Multiple matches — click a suggestion.'); 
      return;
    } else {
      msgEl.text('Search term not found. Please try again.');
    }
  }

  /************************************************************************
   * KEYBOARD SHORTCUTS
   ************************************************************************/
  document.addEventListener('keydown', (e) => {
    // Ctrl+S / Cmd+S to download
    if ((e.ctrlKey || e.metaKey) && e.key === 's') {
      e.preventDefault();
      handleDownload();
    }
    
    // Escape to close confirm dialog
    if (e.key === 'Escape') {
      closeConfirmDialog();
    }
  });

  /************************************************************************
   * INITIAL RENDER
   ************************************************************************/
  render();
  </script>
</body>
</html>